<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BestHTTP</name>
    </assembly>
    <members>
        <member name="T:BestHTTP.Authentication.AuthenticationTypes">
            <summary>
            Authentication types that supported by BestHTTP.
            The authentication is defined by the server, so the Basic and Digest are not interchangeable. If you don't know what to use, the preferred way is to choose Unknow.
            </summary>
        </member>
        <member name="F:BestHTTP.Authentication.AuthenticationTypes.Unknown">
            <summary>
            If the authentication type is not known this will do a challenge turn to receive what methode should be choosen.
            </summary>
        </member>
        <member name="F:BestHTTP.Authentication.AuthenticationTypes.Basic">
            <summary>
            The most basic authentication type. It's easy to do, and easy to crack. ;)
            </summary>
        </member>
        <member name="F:BestHTTP.Authentication.AuthenticationTypes.Digest">
            <summary>
            
            </summary>
        </member>
        <member name="T:BestHTTP.Authentication.Credentials">
            <summary>
            Hold all information that required to authenticate to a remote server.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Credentials.Type">
            <summary>
            The type of the Authentication. If you don't know what to use, the preferred way is to choose Unknow.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Credentials.UserName">
            <summary>
            The username to authenticate on the remote server.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Credentials.Password">
            <summary>
            The password to use in the authentication process. The password will be stored only in this class.
            </summary>
        </member>
        <member name="M:BestHTTP.Authentication.Credentials.#ctor(System.String,System.String)">
            <summary>
            Set up the authentication credentials with the username and password. The Type will be set to Unknown.
            </summary>
        </member>
        <member name="M:BestHTTP.Authentication.Credentials.#ctor(BestHTTP.Authentication.AuthenticationTypes,System.String,System.String)">
            <summary>
            Set up the authentication credentials with the given authentication type, username and password.
            </summary>
        </member>
        <member name="T:BestHTTP.Authentication.Digest">
            <summary>
            Internal class that stores all information that received from a server in a WWW-Authenticate and need to construct a valid Authorization header. Based on rfc 2617 (http://tools.ietf.org/html/rfc2617).
            Used only internally by the plugin.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.Uri">
            <summary>
            The Uri that this Digest is bound to.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.Realm">
            <summary>
            A string to be displayed to users so they know which username and password to use.
            This string should contain at least the name of the host performing the authentication and might additionally indicate the collection of users who might have access.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.Stale">
            <summary>
            A flag, indicating that the previous request from the client was rejected because the nonce value was stale.
            If stale is TRUE (case-insensitive), the client may wish to simply retry the request with a new encrypted response, without  the user for a new username and password.
            The server should only set stale to TRUE if it receives a request for which the nonce is invalid but with a valid digest for that nonce
            (indicating that the client knows the correct username/password).
            If stale is FALSE, or anything other than TRUE, or the stale directive is not present, the username and/or password are invalid, and new values must be obtained.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.Nonce">
            <summary>
            A server-specified data string which should be uniquely generated each time a 401 response is made.
            Specifically, since the string is passed in the header lines as a quoted string, the double-quote character is not allowed.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.Opaque">
            <summary>
            A string of data, specified by the server, which should be returned by the client unchanged in the Authorization header of subsequent requests with URIs in the same protection space.
            It is recommended that this string be base64 or data.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.Algorithm">
            <summary>
            A string indicating a pair of algorithms used to produce the digest and a checksum. If this is not present it is assumed to be "MD5".
            If the algorithm is not understood, the challenge should be ignored (and a different one used, if there is more than one).
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.ProtectedUris">
            <summary>
            List of URIs, as specified in RFC XURI, that define the protection space.
            If a URI is an abs_path, it is relative to the canonical root URL (see section 1.2 above) of the server being accessed.
            An absoluteURI in this list may refer to a different server than the one being accessed.
            The client can use this list to determine the set of URIs for which the same authentication information may be sent:
            any URI that has a URI in this list as a prefix (after both have been made absolute) may be assumed to be in the same protection space.
            If this directive is omitted or its value is empty, the client should assume that the protection space consists of all URIs on the responding server.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.QualityOfProtections">
            <summary>
            If present, it is a quoted string of one or more tokens indicating the "quality of protection" values supported by the server.
            The value "auth" indicates authentication. The value "auth-int" indicates authentication with integrity protection.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.NonceCount">
            <summary>
            his MUST be specified if a qop directive is sent (see above), and MUST NOT be specified if the server did not send a qop directive in the WWW-Authenticate header field.
            The nc-value is the hexadecimal count of the number of requests (including the current request) that the client has sent with the nonce value in this request.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.HA1Sess">
            <summary>
            Used to store the last HA1 that can be used in the next header generation when Algorithm is set to "md5-sess".
            </summary>
        </member>
        <member name="M:BestHTTP.Authentication.Digest.ParseChallange(System.String)">
            <summary>
            Parses a WWW-Authenticate header's value to retrive all information.
            </summary>
        </member>
        <member name="M:BestHTTP.Authentication.Digest.GenerateResponseHeader(BestHTTP.HTTPRequest,BestHTTP.Authentication.Credentials)">
            <summary>
            Generates a string that can be set to an Authorization header.
            </summary>
        </member>
        <member name="T:BestHTTP.Authentication.DigestStore">
            <summary>
            Stores and manages already received digest infos.
            </summary>
        </member>
        <member name="F:BestHTTP.Authentication.DigestStore.SupportedAlgorithms">
            <summary>
            Array of algorithms that the plugin supports. It's in the order of priority(first has the highest priority).
            </summary>
        </member>
        <member name="M:BestHTTP.Authentication.DigestStore.GetOrCreate(System.Uri)">
            <summary>
            It will retrive or create a new Digest for the given Uri.
            </summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="P:BestHTTP.ConnectionBase.ServerAddress">
            <summary>
            The address of the server that this connection is bound to.
            </summary>
        </member>
        <member name="P:BestHTTP.ConnectionBase.State">
            <summary>
            The state of this connection.
            </summary>
        </member>
        <member name="P:BestHTTP.ConnectionBase.IsFree">
            <summary>
            It's true if this connection is available to process a HTTPRequest.
            </summary>
        </member>
        <member name="P:BestHTTP.ConnectionBase.IsActive">
            <summary>
            Returns true if it's an active connection.
            </summary>
        </member>
        <member name="P:BestHTTP.ConnectionBase.CurrentRequest">
            <summary>
            If the State is HTTPConnectionStates.Processing, then it holds a HTTPRequest instance. Otherwise it's null.
            </summary>
        </member>
        <member name="P:BestHTTP.ConnectionBase.StartTime">
            <summary>
            When we start to process the current request. It's set after the connection is established.
            </summary>
        </member>
        <member name="P:BestHTTP.ConnectionBase.TimedOutStart">
            <summary>
            When this connection timed out.
            </summary>
        </member>
        <member name="M:BestHTTP.WebGLConnection.XHR_SetTimeout(System.Int32,System.UInt32)">
            <summary>
            Is an unsigned long representing the number of milliseconds a request can take before automatically being terminated. A value of 0 (which is the default) means there is no timeout.
            </summary>
        </member>
        <member name="T:BestHTTP.Decompression.Crc.CRC32">
            <summary>
              Computes a CRC-32. The CRC-32 algorithm is parameterized - you
              can set the polynomial and enable or disable bit
              reversal. This can be used for GZIP, BZip2, or ZIP.
            </summary>
            <remarks>
              This type is used internally by DotNetZip; it is generally not used
              directly by applications wishing to create, read, or manipulate zip
              archive files.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Crc.CRC32.TotalBytesRead">
            <summary>
              Indicates the total number of bytes applied to the CRC.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Crc.CRC32.Crc32Result">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the
            output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.ComputeCrc32(System.Int32,System.Byte)">
            <summary>
              Get the CRC32 for the given (word,byte) combo.  This is a
              computation defined by PKzip for PKZIP 2.0 (weak) encryption.
            </summary>
            <param name="W">The word to start with.</param>
            <param name="B">The byte to combine it with.</param>
            <returns>The CRC-ized result.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
            <param name="block">block of bytes to slurp</param>
            <param name="offset">starting point in the block</param>
            <param name="count">how many bytes within the block to slurp</param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.UpdateCRC(System.Byte)">
            <summary>
              Process one byte in the CRC.
            </summary>
            <param name = "b">the byte to include into the CRC .  </param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.UpdateCRC(System.Byte,System.Int32)">
            <summary>
              Process a run of N identical bytes into the CRC.
            </summary>
            <remarks>
              <para>
                This method serves as an optimization for updating the CRC when a
                run of identical bytes is found. Rather than passing in a buffer of
                length n, containing all identical bytes b, this method accepts the
                byte value and the length of the (virtual) buffer - the length of
                the run.
              </para>
            </remarks>
            <param name = "b">the byte to include into the CRC.  </param>
            <param name = "n">the number of times that byte should be repeated. </param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.Combine(System.Int32,System.Int32)">
            <summary>
              Combines the given CRC32 value with the current running total.
            </summary>
            <remarks>
              This is useful when using a divide-and-conquer approach to
              calculating a CRC.  Multiple threads can each calculate a
              CRC32 on a segment of the data, and then combine the
              individual CRC32 values at the end.
            </remarks>
            <param name="crc">the crc value to be combined with this one</param>
            <param name="length">the length of data the CRC value was calculated on</param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.#ctor">
            <summary>
              Create an instance of the CRC32 class using the default settings: no
              bit reversal, and a polynomial of 0xEDB88320.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.#ctor(System.Boolean)">
            <summary>
              Create an instance of the CRC32 class, specifying whether to reverse
              data bits or not.
            </summary>
            <param name='reverseBits'>
              specify true if the instance should reverse data bits.
            </param>
            <remarks>
              <para>
                In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                want a CRC32 with compatibility with BZip2, you should pass true
                here. In the CRC-32 used by GZIP and PKZIP, the bits are not
                reversed; Therefore if you want a CRC32 with compatibility with
                those, you should pass false.
              </para>
            </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.#ctor(System.Int32,System.Boolean)">
             <summary>
               Create an instance of the CRC32 class, specifying the polynomial and
               whether to reverse data bits or not.
             </summary>
             <param name='polynomial'>
               The polynomial to use for the CRC, expressed in the reversed (LSB)
               format: the highest ordered bit in the polynomial value is the
               coefficient of the 0th power; the second-highest order bit is the
               coefficient of the 1 power, and so on. Expressed this way, the
               polynomial for the CRC-32C used in IEEE 802.3, is 0xEDB88320.
             </param>
             <param name='reverseBits'>
               specify true if the instance should reverse data bits.
             </param>
            
             <remarks>
               <para>
                 In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                 want a CRC32 with compatibility with BZip2, you should pass true
                 here for the <c>reverseBits</c> parameter. In the CRC-32 used by
                 GZIP and PKZIP, the bits are not reversed; Therefore if you want a
                 CRC32 with compatibility with those, you should pass false for the
                 <c>reverseBits</c> parameter.
               </para>
             </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.Reset">
            <summary>
              Reset the CRC-32 class - clear the CRC "remainder register."
            </summary>
            <remarks>
              <para>
                Use this when employing a single instance of this class to compute
                multiple, distinct CRCs on multiple, distinct data blocks.
              </para>
            </remarks>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.DeflateStream">
             <summary>
             A class for compressing and decompressing streams using the Deflate algorithm.
             </summary>
            
             <remarks>
            
             <para>
               The DeflateStream is a <see
               href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see
               cref="T:System.IO.Stream"/>.  It adds DEFLATE compression or decompression to any
               stream.
             </para>
            
             <para>
               Using this stream, applications can compress or decompress data via stream
               <c>Read</c> and <c>Write</c> operations.  Either compresssion or decompression
               can occur through either reading or writing. The compression format used is
               DEFLATE, which is documented in <see
               href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
               Compressed Data Format Specification version 1.3.".
             </para>
            
             </remarks>
            
             <seealso cref="T:BestHTTP.Decompression.Zlib.GZipStream" />
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode)">
             <summary>
               Create a DeflateStream using the specified CompressionMode.
             </summary>
            
             <remarks>
               When mode is <c>CompressionMode.Compress</c>, the DeflateStream will use
               the default compression level. The "captive" stream will be closed when
               the DeflateStream is closed.
             </remarks>
            
             <example>
             This example uses a DeflateStream to compress data from a file, and writes
             the compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,BestHTTP.Decompression.Zlib.CompressionLevel)">
             <summary>
             Create a DeflateStream using the specified CompressionMode and the specified CompressionLevel.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is
               ignored.  The "captive" stream will be closed when the DeflateStream is
               closed.
             </para>
            
             </remarks>
            
             <example>
            
               This example uses a DeflateStream to compress data from a file, and writes
               the compressed data to another file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw,
                                                                  CompressionMode.Compress,
                                                                  CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>DeflateStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified
               <c>CompressionMode</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compression.  Specify true for
               the <paramref name="leaveOpen"/> parameter to leave the stream open.
             </para>
            
             <para>
               The <c>DeflateStream</c> will use the default compression level.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the
               "captive" stream in other places in this documentation.
             </param>
            
             <param name="mode">
               Indicates whether the <c>DeflateStream</c> will compress or decompress.
             </param>
            
             <param name="leaveOpen">true if the application would like the stream to
             remain open after inflation/deflation.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,BestHTTP.Decompression.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify whether
               the stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
             </para>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream"/> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen"/> parameter
               to leave the stream open.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to use a <c>DeflateStream</c> to compress data from
               a file, and store the compressed data into another file.
            
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".deflated"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code>
            
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".deflated")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,BestHTTP.Decompression.Zlib.CompressionLevel,System.Boolean,System.Int32)">
             <summary>
               Create a <c>DeflateStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify whether
               the stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
             </para>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream"/> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen"/> parameter
               to leave the stream open.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to use a <c>DeflateStream</c> to compress data from
               a file, and store the compressed data into another file.
            
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".deflated"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code>
            
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".deflated")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
             <param name="windowBits">Desired window bits.</param>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
            <remarks> See the ZLIB documentation for the meaning of the flush behavior.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.Strategy">
             <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            
             <remarks>
               By tweaking this parameter, you may be able to optimize the compression for
               data with particular characteristics.
             </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                Application code won't call this code directly.  This method may be
                invoked in two distinct scenarios.  If disposing == true, the method
                has been called directly or indirectly by a user's code, for example
                via the public Dispose() method. In this case, both managed and
                unmanaged resources can be referenced and disposed.  If disposing ==
                false, the method has been called by the runtime from inside the
                object finalizer and this method should not reference other objects;
                in that case only unmanaged resources must be referenced or
                disposed.
              </para>
            </remarks>
            <param name="disposing">
              true if the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, providing an uncompressed data stream.
               Then call Read() on that <c>DeflateStream</c>, and the data read will be
               compressed as you read.  If you wish to use the <c>DeflateStream</c> to
               decompress data while reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, providing a readable compressed data
               stream.  Then call Read() on that <c>DeflateStream</c>, and the data read
               will be decompressed as you read.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
            
             </remarks>
             <param name="buffer">The buffer into which the read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.SetLength(System.Int64)">
            <summary>
            Will call the base stream's SetLength method.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, and a writable output stream.  Then call
               <c>Write()</c> on that <c>DeflateStream</c>, providing uncompressed data
               as input.  The data sent to the output stream will be the compressed form
               of the data written.  If you wish to use the <c>DeflateStream</c> to
               decompress data while writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, and a writable output stream.  Then
               call <c>Write()</c> on that stream, providing previously compressed
               data. The data sent to the output stream will be the decompressed form of
               the data written.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>,
               but not both.
             </para>
            
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using DEFLATE (RFC 1951).
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressString(System.Byte[])">DeflateStream.UncompressString(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.CompressBuffer(System.Byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressString(System.String)">GZipStream.CompressString(string)</seealso>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using DEFLATE.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.CompressString(System.String)">DeflateStream.CompressString(string)</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressBuffer(System.Byte[])">GZipStream.CompressBuffer(byte[])</seealso>
            
             <param name="b">
               A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a DEFLATE'd byte array into a single string.
             </summary>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.CompressString(System.String)">DeflateStream.CompressString(String)</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressString(System.Byte[])">GZipStream.UncompressString(byte[])</seealso>
            
             <param name="compressed">
               A buffer containing DEFLATE-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a DEFLATE'd byte array into a byte array.
             </summary>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.CompressBuffer(System.Byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressString(System.Byte[])">DeflateStream.UncompressString(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressBuffer(System.Byte[])">GZipStream.UncompressBuffer(byte[])</seealso>
            
             <param name="compressed">
               A buffer containing data that has been compressed with DEFLATE.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.GZipStream">
             <summary>
               A class for compressing and decompressing GZIP streams.
             </summary>
             <remarks>
            
             <para>
               The <c>GZipStream</c> is a <see
               href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a
               <see cref="T:System.IO.Stream"/>. It adds GZIP compression or decompression to any
               stream.
             </para>
            
             <para>
               Like the <c>System.IO.Compression.GZipStream</c> in the .NET Base Class Library, the
               <c>Ionic.Zlib.GZipStream</c> can compress while writing, or decompress while
               reading, but not vice versa.  The compression method used is GZIP, which is
               documented in <see href="http://www.ietf.org/rfc/rfc1952.txt">IETF RFC
               1952</see>, "GZIP file format specification version 4.3".</para>
            
             <para>
               A <c>GZipStream</c> can be used to decompress data (through <c>Read()</c>) or
               to compress data (through <c>Write()</c>), but not both.
             </para>
            
             <para>
               If you wish to use the <c>GZipStream</c> to compress data, you must wrap it
               around a write-able stream. As you call <c>Write()</c> on the <c>GZipStream</c>, the
               data will be compressed into the GZIP format.  If you want to decompress data,
               you must wrap the <c>GZipStream</c> around a readable stream that contains an
               IETF RFC 1952-compliant stream.  The data will be decompressed as you call
               <c>Read()</c> on the <c>GZipStream</c>.
             </para>
            
             <para>
               Though the GZIP format allows data from multiple files to be concatenated
               together, this stream handles only a single segment of GZIP format, typically
               representing a single file.
             </para>
            
             </remarks>
            
             <seealso cref="T:BestHTTP.Decompression.Zlib.DeflateStream" />
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.Comment">
             <summary>
               The comment on the GZIP stream.
             </summary>
            
             <remarks>
             <para>
               The GZIP format allows for each file to optionally have an associated
               comment stored with the file.  The comment is encoded with the ISO-8859-1
               code page.  To include a comment in a GZIP stream you create, set this
               property before calling <c>Write()</c> for the first time on the
               <c>GZipStream</c>.
             </para>
            
             <para>
               When using <c>GZipStream</c> to decompress, you can retrieve this property
               after the first call to <c>Read()</c>.  If no comment has been set in the
               GZIP bytestream, the Comment property will return <c>null</c>
               (<c>Nothing</c> in VB).
             </para>
             </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.FileName">
             <summary>
               The FileName for the GZIP stream.
             </summary>
            
             <remarks>
            
             <para>
               The GZIP format optionally allows each file to have an associated
               filename.  When compressing data (through <c>Write()</c>), set this
               FileName before calling <c>Write()</c> the first time on the <c>GZipStream</c>.
               The actual filename is encoded into the GZIP bytestream with the
               ISO-8859-1 code page, according to RFC 1952. It is the application's
               responsibility to insure that the FileName can be encoded and decoded
               correctly with this code page.
             </para>
            
             <para>
               When decompressing (through <c>Read()</c>), you can retrieve this value
               any time after the first <c>Read()</c>.  In the case where there was no filename
               encoded into the GZIP bytestream, the property will return <c>null</c> (<c>Nothing</c>
               in VB).
             </para>
             </remarks>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.GZipStream.LastModified">
             <summary>
               The last modified time for the GZIP stream.
             </summary>
            
             <remarks>
               GZIP allows the storage of a last modified time with each GZIP entity.
               When compressing data, you can set this before the first call to
               <c>Write()</c>.  When decompressing, you can retrieve this value any time
               after the first call to <c>Read()</c>.
             </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.Crc32">
            <summary>
            The CRC on the GZIP stream.
            </summary>
            <remarks>
            This is used for internal error checking. You probably don't need to look at this property.
            </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>.
             </summary>
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>GZipStream</c> will use the
               default compression level.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with
               <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a GZipStream to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
            
             <example>
             This example shows how to use a GZipStream to uncompress a file.
             <code>
             private void GunZipFile(string filename)
             {
                 if (!filename.EndsWith(".gz))
                     throw new ArgumentException("filename");
                 var DecompressedFile = filename.Substring(0,filename.Length-3);
                 byte[] working = new byte[WORKING_BUFFER_SIZE];
                 int n= 1;
                 using (System.IO.Stream input = System.IO.File.OpenRead(filename))
                 {
                     using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                     {
                         using (var output = System.IO.File.Create(DecompressedFile))
                         {
                             while (n !=0)
                             {
                                 n= decompressor.Read(working, 0, working.Length);
                                 if (n > 0)
                                 {
                                     output.Write(working, 0, n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub GunZipFile(ByVal filename as String)
                 If Not (filename.EndsWith(".gz)) Then
                     Throw New ArgumentException("filename")
                 End If
                 Dim DecompressedFile as String = filename.Substring(0,filename.Length-3)
                 Dim working(WORKING_BUFFER_SIZE) as Byte
                 Dim n As Integer = 1
                 Using input As Stream = File.OpenRead(filename)
                     Using decompressor As Stream = new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, True)
                         Using output As Stream = File.Create(UncompressedFile)
                             Do
                                 n= decompressor.Read(working, 0, working.Length)
                                 If n > 0 Then
                                     output.Write(working, 0, n)
                                 End IF
                             Loop While (n  > 0)
                         End Using
                     End Using
                 End Using
             End Sub
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,BestHTTP.Decompression.Zlib.CompressionLevel)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
             <remarks>
            
             <para>
               The <c>CompressionMode</c> (Compress or Decompress) also establishes the
               "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A
               <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a <c>GZipStream</c> to compress a file into a .gz file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".gz"))
                 {
                     using (Stream compressor = new GZipStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".gz")
                     Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>GZipStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the stream should be left open after Deflation
               or Inflation.
             </summary>
            
             <remarks>
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to leave
               the stream open.
             </para>
            
             <para>
               The <see cref="T:BestHTTP.Decompression.Zlib.CompressionMode"/> (Compress or Decompress) also
               establishes the "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A <c>GZipStream</c>
               with <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             <para>
               The <c>GZipStream</c> will use the default compression level. If you want
               to specify the compression level, see <see cref="M:BestHTTP.Decompression.Zlib.GZipStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,BestHTTP.Decompression.Zlib.CompressionLevel,System.Boolean)"/>.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
            
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the "captive"
               stream in other places in this documentation.
             </param>
            
             <param name="mode">Indicates whether the GZipStream will compress or decompress.
             </param>
            
             <param name="leaveOpen">
               true if the application would like the base stream to remain open after
               inflation/deflation.
             </param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,BestHTTP.Decompression.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and the
               specified <c>CompressionLevel</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to
               leave the stream open.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a <c>GZipStream</c> to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                This method may be invoked in two distinct scenarios.  If disposing
                == true, the method has been called directly or indirectly by a
                user's code, for example via the public Dispose() method. In this
                case, both managed and unmanaged resources can be referenced and
                disposed.  If disposing == false, the method has been called by the
                runtime from inside the object finalizer and this method should not
                reference other objects; in that case only unmanaged resources must
                be referenced or disposed.
              </para>
            </remarks>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.Position">
             <summary>
               The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read and decompress data from the source stream.
             </summary>
            
             <remarks>
               With a <c>GZipStream</c>, decompression is done through reading.
             </remarks>
            
             <example>
             <code>
             byte[] working = new byte[WORKING_BUFFER_SIZE];
             using (System.IO.Stream input = System.IO.File.OpenRead(_CompressedFile))
             {
                 using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                 {
                     using (var output = System.IO.File.Create(_DecompressedFile))
                     {
                         int n;
                         while ((n= decompressor.Read(working, 0, working.Length)) !=0)
                         {
                             output.Write(working, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
             <param name="buffer">The buffer into which the decompressed data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">irrelevant; it will always throw!</param>
            <param name="origin">irrelevant; it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.SetLength(System.Int64)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">irrelevant; this method will always throw!</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
             <para>
               If you wish to use the <c>GZipStream</c> to compress data while writing,
               you can create a <c>GZipStream</c> with <c>CompressionMode.Compress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that <c>GZipStream</c>,
               providing uncompressed data as input.  The data sent to the output stream
               will be the compressed form of the data written.
             </para>
            
             <para>
               A <c>GZipStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not
               both. Writing implies compression.  Reading implies decompression.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressString(System.Byte[])"/>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="b">
               A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a single string.
             </summary>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing GZIP-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a byte array.
             </summary>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressString(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing data that has been compressed with GZip.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.FlushType">
            <summary>
            Describes how to flush the current deflate operation.
            </summary>
            <remarks>
            The different FlushType values are useful when using a Deflate in a streaming application.
            </remarks>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.FlushType.None">
            <summary>No flush at all.</summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.FlushType.Partial">
            <summary>Closes the current block, but doesn't flush it to
            the output. Used internally only in hypothetical
            scenarios.  This was supposed to be removed by Zlib, but it is
            still in use in some edge cases.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.FlushType.Sync">
            <summary>
            Use this during compression to specify that all pending output should be
            flushed to the output buffer and the output should be aligned on a byte
            boundary.  You might use this in a streaming communication scenario, so that
            the decompressor can get all input data available so far.  When using this
            with a ZlibCodec, <c>AvailableBytesIn</c> will be zero after the call if
            enough output space has been provided before the call.  Flushing will
            degrade compression and so it should be used only when necessary.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.FlushType.Full">
            <summary>
            Use this during compression to specify that all output should be flushed, as
            with <c>FlushType.Sync</c>, but also, the compression state should be reset
            so that decompression can restart from this point if previous compressed
            data has been damaged or if random access is desired.  Using
            <c>FlushType.Full</c> too often can significantly degrade the compression.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.FlushType.Finish">
            <summary>Signals the end of the compression/decompression stream.</summary>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.CompressionLevel">
            <summary>
            The compression level to be used when using a DeflateStream or ZlibStream with CompressionMode.Compress.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.None">
            <summary>
            None means that the data will be simply stored, with no change at all.
            If you are producing ZIPs for use on Mac OSX, be aware that archives produced with CompressionLevel.None
            cannot be opened with the default zip reader. Use a different CompressionLevel.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level0">
            <summary>
            Same as None.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.BestSpeed">
            <summary>
            The fastest but least effective compression.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level1">
            <summary>
            A synonym for BestSpeed.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level2">
            <summary>
            A little slower, but better, than level 1.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level3">
            <summary>
            A little slower, but better, than level 2.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level4">
            <summary>
            A little slower, but better, than level 3.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level5">
            <summary>
            A little slower than level 4, but with better compression.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Default">
            <summary>
            The default compression level, with a good balance of speed and compression efficiency.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level6">
            <summary>
            A synonym for Default.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level7">
            <summary>
            Pretty good compression!
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level8">
            <summary>
             Better compression than Level7!
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.BestCompression">
            <summary>
            The "best" compression, where best means greatest reduction in size of the input data stream.
            This is also the slowest compression.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level9">
            <summary>
            A synonym for BestCompression.
            </summary>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.CompressionStrategy">
            <summary>
            Describes options for how the compression algorithm is executed.  Different strategies
            work better on different sorts of data.  The strategy parameter can affect the compression
            ratio and the speed of compression but not the correctness of the compresssion.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionStrategy.Default">
            <summary>
            The default strategy is probably the best for normal data.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionStrategy.Filtered">
            <summary>
            The <c>Filtered</c> strategy is intended to be used most effectively with data produced by a
            filter or predictor.  By this definition, filtered data consists mostly of small
            values with a somewhat random distribution.  In this case, the compression algorithm
            is tuned to compress them better.  The effect of <c>Filtered</c> is to force more Huffman
            coding and less string matching; it is a half-step between <c>Default</c> and <c>HuffmanOnly</c>.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionStrategy.HuffmanOnly">
            <summary>
            Using <c>HuffmanOnly</c> will force the compressor to do Huffman encoding only, with no
            string matching.
            </summary>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.CompressionMode">
            <summary>
            An enum to specify the direction of transcoding - whether to compress or decompress.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionMode.Compress">
            <summary>
            Used to specify that the stream should compress the data.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionMode.Decompress">
            <summary>
            Used to specify that the stream should decompress the data.
            </summary>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.ZlibException">
            <summary>
            A general purpose exception class for exceptions in the Zlib library.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibException.#ctor">
            <summary>
            The ZlibException class captures exception information generated
            by the Zlib library.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibException.#ctor(System.String)">
            <summary>
            This ctor collects a message attached to the exception.
            </summary>
            <param name="s">the message for the exception.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.SharedUtils.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.SharedUtils.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
             <summary>
               Reads a number of characters from the current source TextReader and writes
               the data to the target array at the specified index.
             </summary>
            
             <param name="sourceTextReader">The source TextReader to read from</param>
             <param name="target">Contains the array of characteres read from the source TextReader.</param>
             <param name="start">The starting index of the target array.</param>
             <param name="count">The maximum number of characters to read from the source TextReader.</param>
            
             <returns>
               The number of characters read. The number will be less than or equal to
               count depending on the data available in the source TextReader. Returns -1
               if the end of the stream is reached.
             </returns>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.Adler">
             <summary>
             Computes an Adler-32 checksum.
             </summary>
             <remarks>
             The Adler checksum is similar to a CRC checksum, but faster to compute, though less
             reliable.  It is used in producing RFC1950 compressed streams.  The Adler checksum
             is a required part of the "ZLIB" standard.  Applications will almost never need to
             use this class directly.
             </remarks>
            
             <exclude/>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.Adler.Adler32(System.UInt32,System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calculates the Adler32 checksum.
            </summary>
            <remarks>
              <para>
                This is used within ZLIB.  You probably don't need to use this directly.
              </para>
            </remarks>
            <example>
               To compute an Adler32 checksum on a byte array:
             <code>
               var adler = Adler.Adler32(0, null, 0, 0);
               adler = Adler.Adler32(adler, buffer, index, length);
             </code>
            </example>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.ZlibCodec">
             <summary>
             Encoder and Decoder for ZLIB and DEFLATE (IETF RFC1950 and RFC1951).
             </summary>
            
             <remarks>
             This class compresses and decompresses data according to the Deflate algorithm
             and optionally, the ZLIB format, as documented in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - ZLIB</see> and <see
             href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951 - DEFLATE</see>.
             </remarks>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.InputBuffer">
            <summary>
            The buffer from which data is taken.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.NextIn">
            <summary>
            An index into the InputBuffer array, indicating where to start reading. 
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.AvailableBytesIn">
            <summary>
            The number of bytes available in the InputBuffer, starting at NextIn. 
            </summary>
            <remarks>
            Generally you should set this to InputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.TotalBytesIn">
            <summary>
            Total number of bytes read so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.OutputBuffer">
            <summary>
            Buffer to store output data.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.NextOut">
            <summary>
            An index into the OutputBuffer array, indicating where to start writing. 
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.AvailableBytesOut">
            <summary>
            The number of bytes available in the OutputBuffer, starting at NextOut. 
            </summary>
            <remarks>
            Generally you should set this to OutputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.TotalBytesOut">
            <summary>
            Total number of bytes written to the output so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.Message">
            <summary>
            used for diagnostics, when something goes wrong!
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.CompressLevel">
            <summary>
            The compression level to use in this codec.  Useful only in compression mode.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.WindowBits">
            <summary>
            The number of Window Bits to use.  
            </summary>
            <remarks>
            This gauges the size of the sliding window, and hence the 
            compression effectiveness as well as memory consumption. It's best to just leave this 
            setting alone if you don't know what it is.  The maximum value is 15 bits, which implies
            a 32k window.  
            </remarks>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.Strategy">
            <summary>
            The compression strategy to use.
            </summary>
            <remarks>
            This is only effective in compression.  The theory offered by ZLIB is that different
            strategies could potentially produce significant differences in compression behavior
            for different data sets.  Unfortunately I don't have any good recommendations for how
            to set it differently.  When I tested changing the strategy I got minimally different
            compression performance. It's best to leave this property alone if you don't have a
            good feel for it.  Or, you may want to produce a test harness that runs through the
            different strategy options and evaluates them on different file types. If you do that,
            let me know your results.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.ZlibCodec.Adler32">
            <summary>
            The Adler32 checksum on the data transferred through the codec so far. You probably don't need to look at this.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.#ctor">
            <summary>
            Create a ZlibCodec.
            </summary>
            <remarks>
            If you use this default constructor, you will later have to explicitly call 
            InitializeInflate() or InitializeDeflate() before using the ZlibCodec to compress 
            or decompress. 
            </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.#ctor(BestHTTP.Decompression.Zlib.CompressionMode)">
            <summary>
            Create a ZlibCodec that either compresses or decompresses.
            </summary>
            <param name="mode">
            Indicates whether the codec should compress (deflate) or decompress (inflate).
            </param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeInflate">
            <summary>
            Initialize the inflation state. 
            </summary>
            <remarks>
            It is not necessary to call this before using the ZlibCodec to inflate data; 
            It is implicitly called when you call the constructor.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeInflate(System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to
             govern the handling of RFC1950 header bytes.
             </summary>
            
             <remarks>
             By default, the ZLIB header defined in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</see> is expected.  If
             you want to read a zlib stream you should specify true for
             expectRfc1950Header.  If you have a deflate stream, you will want to specify
             false. It is only necessary to invoke this initializer explicitly if you
             want to specify false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte
             pair when reading the stream of data to be inflated.</param>
            
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeInflate(System.Int32)">
            <summary>
            Initialize the ZlibCodec for inflation, with the specified number of window bits. 
            </summary>
            <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
            then you shouldn't be calling this initializer.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeInflate(System.Int32,System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to govern the handling of
             RFC1950 header bytes. 
             </summary>
            
             <remarks>
             If you want to read a zlib stream you should specify true for
             expectRfc1950Header. In this case, the library will expect to find a ZLIB
             header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
             1950</see>, in the compressed stream.  If you will be reading a DEFLATE or
             GZIP stream, which does not have such a header, you will want to specify
             false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading 
             the stream of data to be inflated.</param>
             <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
             then you shouldn't be calling this initializer.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.Inflate(BestHTTP.Decompression.Zlib.FlushType)">
             <summary>
             Inflate the data in the InputBuffer, placing the result in the OutputBuffer.
             </summary>
             <remarks>
             You must have set InputBuffer and OutputBuffer, NextIn and NextOut, and AvailableBytesIn and 
             AvailableBytesOut  before calling this method.
             </remarks>
             <example>
             <code>
             private void InflateBuffer()
             {
                 int bufferSize = 1024;
                 byte[] buffer = new byte[bufferSize];
                 ZlibCodec decompressor = new ZlibCodec();
             
                 Console.WriteLine("\n============================================");
                 Console.WriteLine("Size of Buffer to Inflate: {0} bytes.", CompressedBytes.Length);
                 MemoryStream ms = new MemoryStream(DecompressedBytes);
             
                 int rc = decompressor.InitializeInflate();
             
                 decompressor.InputBuffer = CompressedBytes;
                 decompressor.NextIn = 0;
                 decompressor.AvailableBytesIn = CompressedBytes.Length;
             
                 decompressor.OutputBuffer = buffer;
             
                 // pass 1: inflate 
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.None);
             
                     if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     ms.Write(decompressor.OutputBuffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 // pass 2: finish and flush
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.Finish);
             
                     if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     if (buffer.Length - decompressor.AvailableBytesOut &gt; 0)
                         ms.Write(buffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 decompressor.EndInflate();
             }
            
             </code>
             </example>
             <param name="flush">The flush to use when inflating.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.EndInflate">
            <summary>
            Ends an inflation session. 
            </summary>
            <remarks>
            Call this after successively calling Inflate().  This will cause all buffers to be flushed. 
            After calling this you cannot call Inflate() without a intervening call to one of the
            InitializeInflate() overloads.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.SyncInflate">
            <summary>
            I don't know what this does!
            </summary>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeDeflate">
            <summary>
            Initialize the ZlibCodec for deflation operation.
            </summary>
            <remarks>
            The codec will use the MAX window bits and the default level of compression.
            </remarks>
            <example>
            <code>
             int bufferSize = 40000;
             byte[] CompressedBytes = new byte[bufferSize];
             byte[] DecompressedBytes = new byte[bufferSize];
             
             ZlibCodec compressor = new ZlibCodec();
             
             compressor.InitializeDeflate(CompressionLevel.Default);
             
             compressor.InputBuffer = System.Text.ASCIIEncoding.ASCII.GetBytes(TextToCompress);
             compressor.NextIn = 0;
             compressor.AvailableBytesIn = compressor.InputBuffer.Length;
             
             compressor.OutputBuffer = CompressedBytes;
             compressor.NextOut = 0;
             compressor.AvailableBytesOut = CompressedBytes.Length;
             
             while (compressor.TotalBytesIn != TextToCompress.Length &amp;&amp; compressor.TotalBytesOut &lt; bufferSize)
             {
               compressor.Deflate(FlushType.None);
             }
             
             while (true)
             {
               int rc= compressor.Deflate(FlushType.Finish);
               if (rc == ZlibConstants.Z_STREAM_END) break;
             }
             
             compressor.EndDeflate();
              
            </code>
            </example>
            <returns>Z_OK if all goes well. You generally don't need to check the return code.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeDeflate(BestHTTP.Decompression.Zlib.CompressionLevel)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified
            CompressionLevel.  It will emit a ZLIB stream as it compresses.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeDeflate(BestHTTP.Decompression.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified CompressionLevel.
            If you want to generate a zlib stream, you should specify true for
            wantRfc1950Header. In this case, the library will emit a ZLIB
            header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
            1950</see>, in the compressed stream.  
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeDeflate(BestHTTP.Decompression.Zlib.CompressionLevel,System.Int32)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the specified number of window bits. 
            </summary>
            <remarks>
            The codec will use the specified number of window bits and the specified CompressionLevel.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeDeflate(BestHTTP.Decompression.Zlib.CompressionLevel,System.Int32,System.Boolean)">
             <summary>
             Initialize the ZlibCodec for deflation operation, using the specified
             CompressionLevel, the specified number of window bits, and the explicit flag
             governing whether to emit an RFC1950 header byte pair.
             </summary>
            
             <param name="level">The compression level for the codec.</param>
             <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
             <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
             <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.Deflate(BestHTTP.Decompression.Zlib.FlushType)">
            <summary>
            Deflate one batch of data.
            </summary>
            <remarks>
            You must have set InputBuffer and OutputBuffer before calling this method.
            </remarks>
            <example>
            <code>
            private void DeflateBuffer(CompressionLevel level)
            {
                int bufferSize = 1024;
                byte[] buffer = new byte[bufferSize];
                ZlibCodec compressor = new ZlibCodec();
            
                Console.WriteLine("\n============================================");
                Console.WriteLine("Size of Buffer to Deflate: {0} bytes.", UncompressedBytes.Length);
                MemoryStream ms = new MemoryStream();
            
                int rc = compressor.InitializeDeflate(level);
            
                compressor.InputBuffer = UncompressedBytes;
                compressor.NextIn = 0;
                compressor.AvailableBytesIn = UncompressedBytes.Length;
            
                compressor.OutputBuffer = buffer;
            
                // pass 1: deflate 
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.None);
            
                    if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                        throw new Exception("deflating: " + compressor.Message);
            
                    ms.Write(compressor.OutputBuffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                // pass 2: finish and flush
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.Finish);
            
                    if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                        throw new Exception("deflating: " + compressor.Message);
            
                    if (buffer.Length - compressor.AvailableBytesOut &gt; 0)
                        ms.Write(buffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                compressor.EndDeflate();
            
                ms.Seek(0, SeekOrigin.Begin);
                CompressedBytes = new byte[compressor.TotalBytesOut];
                ms.Read(CompressedBytes, 0, CompressedBytes.Length);
            }
            </code>
            </example>
            <param name="flush">whether to flush all data as you deflate. Generally you will want to 
            use Z_NO_FLUSH here, in a series of calls to Deflate(), and then call EndDeflate() to 
            flush everything. 
            </param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.EndDeflate">
            <summary>
            End a deflation session.
            </summary>
            <remarks>
            Call this after making a series of one or more calls to Deflate(). All buffers are flushed.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.ResetDeflate">
            <summary>
            Reset a codec for another deflation session.
            </summary>
            <remarks>
            Call this to reset the deflation state.  For example if a thread is deflating
            non-consecutive blocks, you can call Reset() after the Deflate(Sync) of the first
            block and before the next Deflate(None) of the second block.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.SetDeflateParams(BestHTTP.Decompression.Zlib.CompressionLevel,BestHTTP.Decompression.Zlib.CompressionStrategy)">
            <summary>
            Set the CompressionStrategy and CompressionLevel for a deflation session.
            </summary>
            <param name="level">the level of compression to use.</param>
            <param name="strategy">the strategy to use for compression.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.SetDictionary(System.Byte[])">
            <summary>
            Set the dictionary to be used for either Inflation or Deflation.
            </summary>
            <param name="dictionary">The dictionary bytes to use.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.ZlibConstants">
            <summary>
            A bunch of constants used in the Zlib interface.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.WindowBitsMax">
            <summary>
            The maximum number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.WindowBitsDefault">
            <summary>
            The default number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.Z_OK">
            <summary>
            indicates everything is A-OK
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.Z_STREAM_END">
            <summary>
            Indicates that the last operation reached the end of the stream.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.Z_NEED_DICT">
            <summary>
            The operation ended in need of a dictionary. 
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.Z_STREAM_ERROR">
            <summary>
            There was an error with the stream - not enough data, not open and readable, etc.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.Z_DATA_ERROR">
            <summary>
            There was an error with the data - not enough data, bad data, etc.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.Z_BUF_ERROR">
            <summary>
            There was an error with the working buffer.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.WorkingBufferSizeDefault">
            <summary>
            The size of the working buffer used in the ZlibCodec class. Defaults to 8192 bytes.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.WorkingBufferSizeMin">
            <summary>
            The minimum size of the working buffer used in the ZlibCodec class.  Currently it is 128 bytes.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZTree.DistanceCode(System.Int32)">
            <summary>
            Map from a distance to a distance code.
            </summary>
            <remarks> 
            No side effects. _dist_code[256] and _dist_code[257] are never used.
            </remarks>
        </member>
        <member name="M:BestHTTP.Extensions.Extensions.AsciiToString(System.Byte[])">
            <summary>
            On WP8 platform there are no ASCII encoding.
            </summary>
        </member>
        <member name="M:BestHTTP.Extensions.Extensions.GetASCIIBytes(System.String)">
            <summary>
            On WP8 platform there are no ASCII encoding.
            </summary>
        </member>
        <member name="M:BestHTTP.Extensions.Extensions.ReadBuffer(System.IO.Stream,System.Byte[])">
            <summary>
            Will fill the entire buffer from the stream. Will throw an exception when the underlying stream is closed.
            </summary>
        </member>
        <member name="T:BestHTTP.Extensions.HeaderParser">
            <summary>
            Will parse a comma-separeted header value
            </summary>
        </member>
        <member name="T:BestHTTP.Extensions.HeaderValue">
            <summary>
            Used in string parsers. Its Value is optional.
            </summary>
        </member>
        <member name="T:BestHTTP.Extensions.HeartbeatManager">
            <summary>
            A manager class that can handle subscribing and unsubscribeing in the same update.
            </summary>
        </member>
        <member name="T:BestHTTP.Extensions.KeyValuePairList">
            <summary>
            Base class for specialized parsers
            </summary>
        </member>
        <member name="T:BestHTTP.Extensions.WWWAuthenticateHeaderParser">
            <summary>
            Used for parsing WWW-Authenticate headers:
            Digest realm="my realm", nonce="4664b327a2963503ba58bbe13ad672c0", qop=auth, opaque="f7e38bdc1c66fce214f9019ffe43117c"
            </summary>
        </member>
        <member name="T:BestHTTP.Forms.HTTPFieldData">
            <summary>
            This class represents a HTTP Form's field.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.Name">
            <summary>
            The form's field.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.FileName">
            <summary>
            Filename of the field. Optional.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.MimeType">
            <summary>
            Mime-type of the field. Optional
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.Encoding">
            <summary>
            Encoding of the data. Optional
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.Text">
            <summary>
            The field's textual data.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.Binary">
            <summary>
            The field's binary data.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.Payload">
            <summary>
            Will return with the binary data, or if it's not present the textual data will be decoded to binary.
            </summary>
        </member>
        <member name="T:BestHTTP.Forms.HTTPFormBase">
            <summary>
            Base class of a concrete implementation. Don't use it to create a form, use instead one of the already wrote implementation(HTTPMultiPartForm, HTTPUrlEncodedForm), or create a new one by inheriting from this base class.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFormBase.Fields">
            <summary>
            A list that holds the form's fields.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFormBase.IsEmpty">
            <summary>
            Returns true if the Fields has no element.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFormBase.IsChanged">
            <summary>
            True if new fields has been added to our list.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFormBase.HasBinary">
            <summary>
            True if there are at least one form-field with binary data.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFormBase.HasLongValue">
            <summary>
            True if there are at least one form-field with a long textual data.
            </summary>
        </member>
        <member name="M:BestHTTP.Forms.HTTPFormBase.CopyFrom(BestHTTP.Forms.HTTPFormBase)">
            <summary>
            It should 'clone' all the data from the given HTTPFormBase object.
            Called after the form-implementation created.
            </summary>
        </member>
        <member name="M:BestHTTP.Forms.HTTPFormBase.PrepareRequest(BestHTTP.HTTPRequest)">
            <summary>
            Prepares the request to sending a form. It should set only the headers.
            </summary>
        </member>
        <member name="M:BestHTTP.Forms.HTTPFormBase.GetData">
            <summary>
            Prepares and returns with the form's raw data.
            </summary>
        </member>
        <member name="F:BestHTTP.Forms.HTTPFormUsage.Automatic">
            <summary>
            The plugin will try to choose the best form sending method.
            </summary>
        </member>
        <member name="F:BestHTTP.Forms.HTTPFormUsage.UrlEncoded">
            <summary>
            The plugin will use the Url-Encoded form sending.
            </summary>
        </member>
        <member name="F:BestHTTP.Forms.HTTPFormUsage.Multipart">
            <summary>
            The plugin will use the Multipart form sending.
            </summary>
        </member>
        <member name="T:BestHTTP.Forms.HTTPMultiPartForm">
            <summary>
            A HTTP Form implementation to send textual and binary values.
            </summary>
        </member>
        <member name="F:BestHTTP.Forms.HTTPMultiPartForm.Boundary">
            <summary>
            A random boundary generated in the constructor.
            </summary>
        </member>
        <member name="F:BestHTTP.Forms.HTTPMultiPartForm.CachedData">
             <summary>
            
             </summary>
        </member>
        <member name="T:BestHTTP.Forms.HTTPUrlEncodedForm">
            <summary>
            A HTTP Form implementation to send textual values.
            </summary>
        </member>
        <member name="T:BestHTTP.KeepAliveHeader">
            <summary>
            https://tools.ietf.org/html/draft-thomson-hybi-http-timeout-03
            Test servers: http://tools.ietf.org/ http://nginx.org/
            </summary>
        </member>
        <member name="P:BestHTTP.KeepAliveHeader.TimeOut">
            <summary>
            A host sets the value of the "timeout" parameter to the time that the host will allow an idle connection to remain open before it is closed. A connection is idle if no data is sent or received by a host.
            </summary>
        </member>
        <member name="P:BestHTTP.KeepAliveHeader.MaxRequests">
            <summary>
            The "max" parameter has been used to indicate the maximum number of requests that would be made on the connection.This parameter is deprecated.Any limit on requests can be enforced by sending "Connection: close" and closing the connection.
            </summary>
        </member>
        <member name="F:BestHTTP.RetryCauses.None">
            <summary>
            The request processed without any special case.
            </summary>
        </member>
        <member name="F:BestHTTP.RetryCauses.Reconnect">
            <summary>
            If the server closed the connection while we sending a request we should reconnect and send the request again. But we will try it once.
            </summary>
        </member>
        <member name="F:BestHTTP.RetryCauses.Authenticate">
            <summary>
            We need an another try with Authorization header set.
            </summary>
        </member>
        <member name="F:BestHTTP.RetryCauses.ProxyAuthenticate">
            <summary>
            The proxy needs authentication.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPConnection">
            <summary>
            Represents and manages a connection to a server.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPConnectionStates">
            <summary>
            Possible states of a Http Connection.
            The ideal lifecycle of a connection that has KeepAlive is the following: Initial => [Processing => WaitForRecycle => Free] => Closed.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.Initial">
            <summary>
            This Connection instance is just created.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.Processing">
            <summary>
            This Connection is processing a request
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.Redirected">
            <summary>
            The request redirected.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.Upgraded">
            <summary>
            The connection is upgraded from http.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.WaitForProtocolShutdown">
            <summary>
            Wait for the upgraded protocol to shut down.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.WaitForRecycle">
            <summary>
            The Connection is finished processing the request, it's waiting now to deliver it's result.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.Free">
            <summary>
            The request result's delivered, it's now up to processing again.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.AbortRequested">
            <summary>
            A request from outside of the plugin to abort the connection.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.TimedOut">
            <summary>
            The request is not finished in the given time.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.Closed">
            <summary>
            If it's not a KeepAlive connection, or something happend, then we close this connection and remove from the pool.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPManager">
             <summary>
            
             </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.MaxConnectionPerServer">
            <summary>
            The maximum active TCP connections that the client will maintain to a server. Default value is 4. Minimum value is 1.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.KeepAliveDefaultValue">
            <summary>
            Default value of a HTTP request's IsKeepAlive value. Default value is true. If you make rare request to the server it should be changed to false.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.MaxConnectionIdleTime">
            <summary>
            How many time must be passed to destroy that connection after a connection finished its last request. Its default value is 20 seconds.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.CookieJarSize">
            <summary>
            Size of the Cookie Jar in bytes. It's default value is 10485760 (10 MB).
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.EnablePrivateBrowsing">
            <summary>
            If this property is set to true, then new cookies treated as session cookies and these cookies are not saved to disk. Its default value is false;
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.ConnectTimeout">
            <summary>
            Global, default value of the HTTPRequest's ConnectTimeout property. If set to TimeSpan.Zero or lower, no connect timeout logic is executed. Default value is 20 seconds.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.RequestTimeout">
            <summary>
            Global, default value of the HTTPRequest's Timeout property. Default value is 60 seconds.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.Proxy">
            <summary>
            The global, default proxy for all HTTPRequests. The HTTPRequest's Proxy still can be changed per-request. Default value is null.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.Heartbeats">
            <summary>
            Heartbeat manager to use less threads in the plugin. The heartbeat updates are called from the OnUpdate function.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.Logger">
            <summary>
            A basic BestHTTP.Logger.ILogger implementation to be able to log intelligently additional informations about the plugin's internal mechanism.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.MaxPathLength">
            <summary>
            On most systems the maximum length of a path is around 255 character. If a cache entity's path is longer than this value it doesn't get cached. There no platform independent API to query the exact value on the current system, but it's
            exposed here and can be overridden. It's default value is 255.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPManager.Connections">
            <summary>
            All connection has a reference in this Dictionary untill it's removed completly.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPManager.ActiveConnections">
            <summary>
            Active connections. These connections all has a request to process.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPManager.FreeConnections">
            <summary>
            Free connections. They can be removed completly after a specified time.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPManager.RecycledConnections">
            <summary>
            Connections that recycled in the Update loop. If they are not used in the same loop to process a request, they will be transferred to the FreeConnections list.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPManager.RequestQueue">
            <summary>
            List of request that have to wait until there is a free connection to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPManager.CreateConnection(BestHTTP.HTTPRequest,System.String)">
            <summary>
            Factory method to create a concrete connection object.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPManager.CanProcessFromQueue">
            <summary>
            Will return with true when there at least one request that can be processed from the RequestQueue.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPManager.GetConnectionWith(BestHTTP.HTTPRequest)">
            <summary>
            Will return the ConnectionBase object that processing the given request.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPManager.OnUpdate">
            <summary>
            Update function that should be called regularly from a Unity event(Update, LateUpdate). Callbacks are dispatched from this function.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPMethods">
            <summary>
            Some supported methods described in the rfc: http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Get">
            <summary>
            The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI.
            If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the
            entity in the response and not the source text of the process, unless that text happens to be the output of the process.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Head">
            <summary>
            The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response.
            The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the information sent in response to a GET request.
            This method can be used for obtaining metainformation about the entity implied by the request without transferring the entity-body itself.
            This method is often used for testing hypertext links for validity, accessibility, and recent modification.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Post">
            <summary>
            The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line.
            POST is designed to allow a uniform method to cover the following functions:
            <list type="bullet">
                <item><description>Annotation of existing resources;</description></item>
                <item><description>Posting a message to a bulletin board, newsgroup, mailing list, or similar group of articles;</description></item>
                <item><description>Providing a block of data, such as the result of submitting a form, to a data-handling process;</description></item>
                <item><description>Extending a database through an append operation.</description></item>
            </list>
            The actual function performed by the POST method is determined by the server and is usually dependent on the Request-URI.
            The posted entity is subordinate to that URI in the same way that a file is subordinate to a directory containing it,
            a news article is subordinate to a newsgroup to which it is posted, or a record is subordinate to a database.
            The action performed by the POST method might not result in a resource that can be identified by a URI. In this case,
            either 200 (OK) or 204 (No Content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Put">
            <summary>
            The PUT method requests that the enclosed entity be stored under the supplied Request-URI.
            If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server.
            If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent,
            the origin server can create the resource with that URI. If a new resource is created, the origin server MUST inform the user agent via the 201 (Created) response.
            If an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to indicate successful completion of the request.
            If the resource could not be created or modified with the Request-URI, an appropriate error response SHOULD be given that reflects the nature of the problem.
            The recipient of the entity MUST NOT ignore any Content-* (e.g. Content-Range) headers that it does not understand or implement and MUST return a 501 (Not Implemented) response in such cases.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Delete">
            <summary>
            The DELETE method requests that the origin server delete the resource identified by the Request-URI. This method MAY be overridden by human intervention (or other means) on the origin server.
            The client cannot be guaranteed that the operation has been carried out, even if the status code returned from the origin server indicates that the action has been completed successfully.
            However, the server SHOULD NOT indicate success unless, at the time the response is given, it intends to delete the resource or move it to an inaccessible location.
            A successful response SHOULD be 200 (OK) if the response includes an entity describing the status, 202 (Accepted) if the action has not yet been enacted, or 204 (No Content)
            if the action has been enacted but the response does not include an entity.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Patch">
            <summary>
            http://tools.ietf.org/html/rfc5789
            The PATCH method requests that a set of changes described in the request entity be applied to the resource identified by the Request-URI.
            The set of changes is represented in a format called a "patchdocument" identified by a media type. If the Request-URI does not point to an existing resource,
            the server MAY create a new resource, depending on the patch document type (whether it can logically modify a null resource) and permissions, etc.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Merge">
            <summary>
            The HTTP methods PATCH can be used to update partial resources. For instance, when you only need to update one field of the resource, PUTting a complete resource representation might be cumbersome and utilizes more bandwidth.
            <seealso href="http://restcookbook.com/HTTP%20Methods/patch/"/>
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPProxy.Address">
            <summary>
            Address of the proxy server. It has to be in the http://proxyaddress:port form.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPProxy.Credentials">
            <summary>
            Credentials of the proxy
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPProxy.IsTransparent">
            <summary>
            True if the proxy can act as a transparent proxy
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPProxy.SendWholeUri">
            <summary>
            Some non-transparent proxies are except only the path and query of the request uri. Default value is true
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPProxy.NonTransparentForHTTPS">
            <summary>
            Regardless of the value of IsTransparent, for secure protocols(HTTPS://, WSS://) the plugin will use the proxy as an explicit proxy(will issue a CONNECT request to the proxy)
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPRange">
             <summary>
            
             </summary>
        </member>
        <member name="P:BestHTTP.HTTPRange.FirstBytePos">
            <summary>
            The first byte's position that the server sent.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRange.LastBytePos">
            <summary>
            The last byte's position that the server sent.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRange.ContentLength">
            <summary>
            Indicates the total length of the full entity-body on the server, -1 if this length is unknown or difficult to determine.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRange.IsValid">
             <summary>
            
             </summary>
        </member>
        <member name="T:BestHTTP.HTTPRequestStates">
            <summary>
            Possible logical states of a HTTTPRequest object.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.Initial">
            <summary>
            Initial status of a request. No callback will be called with this status.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.Queued">
            <summary>
            Waiting in a queue to be processed. No callback will be called with this status.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.Processing">
            <summary>
            Processing of the request started. In this state the client will send the request, and parse the response. No callback will be called with this status.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.Finished">
            <summary>
            The request finished without problem. Parsing the response done, the result can be used. The user defined callback will be called with a valid response object. The request’s Exception property will be null.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.Error">
            <summary>
            The request finished with an unexpected error. The user defined callback will be called with a null response object. The request's Exception property may contain more info about the error, but it can be null.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.Aborted">
            <summary>
            The request aborted by the client(HTTPRequest’s Abort() function). The user defined callback will be called with a null response. The request’s Exception property will be null.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.ConnectionTimedOut">
            <summary>
            Connecting to the server timed out. The user defined callback will be called with a null response. The request’s Exception property will be null.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.TimedOut">
            <summary>
            The request didn't finished in the given time. The user defined callback will be called with a null response. The request’s Exception property will be null.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPRequest">
             <summary>
            
             </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.MethodNames">
            <summary>
            Cached uppercase values to save some cpu cycles and GC alloc per request.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.UploadChunkSize">
            <summary>
            Size of the internal buffer, and upload progress will be fired when this size of data sent to the wire. It's default value is 2 KiB.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Uri">
            <summary>
            The original request's Uri.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.MethodType">
            <summary>
            The method that how we want to process our request the server.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.RawData">
            <summary>
            The raw data to send in a POST request. If it set all other fields that added to this request will be ignored.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UploadStream">
            <summary>
            The stream that the plugin will use to get the data to send out the server. When this property is set, no forms or the RawData property will be used
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.DisposeUploadStream">
            <summary>
            When set to true(its default value) the plugin will call the UploadStream's Dispose() function when finished uploading the data from it. Default value is true.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UseUploadStreamLength">
            <summary>
            If it's true, the plugin will use the Stream's Length property. Otherwise the plugin will send the data chunked. Default value is true.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.OnUploadProgress">
            <summary>
            Called after data sent out to the wire.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.IsKeepAlive">
            <summary>
            Indicates that the connection should be open after the response received. If its true, then the internal TCP connections will be reused if it's possible. Default value is true.
            The default value can be changed in the HTTPManager class. If you make rare request to the server it's should be changed to false.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UseStreaming">
            <summary>
            If it's true, the Callback will be called every time if we can send out at least one fragment.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.StreamFragmentSize">
            <summary>
            Maximum size of a data chunk that we want to receive when streaming is set.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Callback">
            <summary>
            The callback function that will be called when a request is fully processed or when any downloaded fragment is available if UseStreaming is true. Can be null for fire-and-forget requests.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.OnProgress">
            <summary>
            Called when new data downloaded from the server.
            The first parameter is the original HTTTPRequest object itself, the second parameter is the downloaded bytes while the third parameter is the content length.
            <remarks>There are download modes where we can't figure out the exact length of the final content. In these cases we just guarantee that the third parameter will be at least the size of the second one.</remarks>
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.OnUpgraded">
            <summary>
            Called when the current protocol is upgraded to an other. (HTTP => WebSocket for example)
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.DisableRetry">
            <summary>
            With this option if reading back the server's response fails, the request will fail and any exceptions can be checked through the Exception property. The default value is True for POST requests, otherwise false.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.IsRedirected">
            <summary>
            Indicates that the request is redirected. If a request is redirected, the connection that served it will be closed regardless of the value of IsKeepAlive.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.RedirectUri">
            <summary>
            The Uri that the request redirected to.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.CurrentUri">
            <summary>
            If redirected it contains the RedirectUri.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Response">
            <summary>
            The response to the query.
            <remarks>If an exception occurred during reading of the response stream or can't connect to the server, this will be null!</remarks>
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.ProxyResponse">
            <summary>
            Response from the Proxy server. It's null with transparent proxies.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Exception">
            <summary>
            It there is an exception while processing the request or response the Response property will be null, and the Exception will be stored in this property.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Tag">
            <summary>
            Any object can be passed with the request with this property. (eq. it can be identified, etc.)
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Credentials">
            <summary>
            The UserName, Password pair that the plugin will use to authenticate to the remote server.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.HasProxy">
            <summary>
            True, if there is a Proxy object.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Proxy">
            <summary>
            A web proxy's properties where the request must pass through.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.MaxRedirects">
            <summary>
            How many redirection supported for this request. The default is int.MaxValue. 0 or a negative value means no redirection supported.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.FormUsage">
            <summary>
            What form should used. Default to Automatic.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.State">
            <summary>
            Current state of this request.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.RedirectCount">
            <summary>
            How many times redirected.
            </summary>
        </member>
        <member name="E:BestHTTP.HTTPRequest.CustomCertificationValidator">
            <summary>
            Custom validator for an SslStream. This event will receive the original HTTPRequest, an X509Certificate and an X509Chain objects. It must return true if the certificate valid, false otherwise.
            <remarks>It's called in a thread! Not available on Windows Phone!</remarks>
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.ConnectTimeout">
            <summary>
            Maximum time we wait to establish the connection to the target server. If set to TimeSpan.Zero or lower, no connect timeout logic is executed. Default value is 20 seconds.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Timeout">
            <summary>
            Maximum time we want to wait to the request to finish after the connection is established. Default value is 60 seconds.
            <remarks>It's disabled for streaming requests! See <see cref="P:BestHTTP.HTTPRequest.EnableTimoutForStreaming"/>.</remarks>
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.EnableTimoutForStreaming">
            <summary>
            Set to true to enable Timeouts on streaming request. Default value is false.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.EnableSafeReadOnUnknownContentLength">
            <summary>
            Enables safe read method when the response's length of the content is unknown. Its default value is enabled (true).
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Priority">
            <summary>
            The priority of the request. Higher priority requests will be picked from the request queue sooner than lower priority ones.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.ProtocolHandler">
             <summary>
            
             </summary>
        </member>
        <member name="E:BestHTTP.HTTPRequest.OnBeforeRedirection">
            <summary>
            It's called before the plugin will do a new request to the new uri. The return value of this function will control the redirection: if it's false the redirection is aborted.
            This function is called on a thread other than the main Unity thread!
            </summary>
        </member>
        <member name="E:BestHTTP.HTTPRequest.OnBeforeHeaderSend">
            <summary>
            This event will be fired before the plugin will write headers to the wire. New headers can be added in this callback. This event is called on a non-Unity thread!
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Downloaded">
            <summary>
            How many bytes downloaded so far.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.DownloadLength">
            <summary>
            The length of the content that we are currently downloading.
            If chunked encoding is used, then it is the size of the sum of all previous chunks plus the current one.
            When no Content-Length present and no chunked encoding is used then its size is the currently downloaded size.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.DownloadProgressChanged">
            <summary>
            Set to true when the downloaded bytes are changed, and set to false when the OnProgress event called.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UploadStreamLength">
            <summary>
            Will return the length of the UploadStream, or -1 if it's not supported.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Uploaded">
            <summary>
            How many bytes are sent to the wire
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UploadLength">
            <summary>
            How many bytes are expected we are sending. If we are don't know, then it will be -1.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UploadProgressChanged">
            <summary>
            Set to true when the uploaded bytes are changed, and set to false when the OnUploadProgress event called.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.FieldCollector">
            <summary>
            We will collect the fields and values to the FieldCollector through the AddField and AddBinaryData functions.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.FormImpl">
            <summary>
            When the request about to send the request we will create a specialized form implementation(url-encoded, multipart, or the legacy WWWForm based).
            And we will use this instance to create the data that we will send to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.AddField(System.String,System.String)">
            <summary>
            Add a field with a given string value.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.AddField(System.String,System.String,System.Text.Encoding)">
            <summary>
            Add a field with a given string value.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.AddBinaryData(System.String,System.Byte[])">
            <summary>
            Add a field with binary content to the form.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.AddBinaryData(System.String,System.Byte[],System.String)">
            <summary>
            Add a field with binary content to the form.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.AddBinaryData(System.String,System.Byte[],System.String,System.String)">
            <summary>
            Add a field with binary content to the form.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SetFields(UnityEngine.WWWForm)">
            <summary>
            Set or overwrite the internal form. Remarks: on WP8 it doesn't supported!
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SetForm(BestHTTP.Forms.HTTPFormBase)">
            <summary>
            Manually set a HTTP Form.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.ClearForm">
            <summary>
            Clears all data from the form.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SelectFormImplementation">
            <summary>
            Will create the form implementation based on the value of the FormUsage property.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.AddHeader(System.String,System.String)">
            <summary>
            Adds a header and value pair to the Headers. Use it to add custom headers to the request.
            </summary>
            <example>AddHeader("User-Agent', "FooBar 1.0")</example>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SetHeader(System.String,System.String)">
            <summary>
            Removes any previously added values, and sets the given one.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.RemoveHeader(System.String)">
            <summary>
            Removes the specified header. Returns true, if the header found and succesfully removed.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:BestHTTP.HTTPRequest.HasHeader(System.String)">
            <summary>
            Returns true if the given head name is already in the Headers.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.GetFirstHeaderValue(System.String)">
            <summary>
            Returns the first header or null for the given header name.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.GetHeaderValues(System.String)">
            <summary>
            Returns all header values for the given header or null.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SetRangeHeader(System.Int32)">
            <summary>
            Sets the Range header to download the content from the given byte position. See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35
            </summary>
            <param name="firstBytePos">Start position of the download.</param>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SetRangeHeader(System.Int32,System.Int32)">
            <summary>
            Sets the Range header to download the content from the given byte position to the given last position. See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35
            </summary>
            <param name="firstBytePos">Start position of the download.</param>
            <param name="lastBytePos">The end position of the download.</param>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SendHeaders(System.IO.Stream)">
            <summary>
            Writes out the Headers to the stream.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.DumpHeaders">
            <summary>
            Returns a string representation of the headers.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.Prepare">
            <summary>
            Called on Unity's main thread just before processing it.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.Send">
            <summary>
            Starts processing the request.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.Abort">
            <summary>
            Aborts an already established connection, so no further download or upload are done.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.Clear">
            <summary>
            Resets the request for a state where switching MethodType is possible.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPResponse">
             <summary>
            
             </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.StatusCode">
            <summary>
            The status code that sent from the server.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.IsSuccess">
            <summary>
            Returns true if the status code is in the range of [200..300[ or 304 (Not Modified)
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.Message">
            <summary>
            The message that sent along with the StatusCode from the server. You can check it for errors from the server.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.IsStreamed">
            <summary>
            True if it's a streamed response.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.IsStreamingFinished">
            <summary>
            True if the streaming is finished, and no more fragments are coming.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.Headers">
            <summary>
            The headers that sent from the server.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.Data">
            <summary>
            The data that downloaded from the server. All Transfer and Content encodings decoded if any(eg. chunked, gzip, deflate).
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.IsUpgraded">
            <summary>
            The normal HTTP protocol is upgraded to an other.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPResponse.dataAsText">
            <summary>
            Cached, converted data.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.DataAsText">
            <summary>
            The data converted to an UTF8 string.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPResponse.texture">
            <summary>
            Cached converted data.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.DataAsTexture2D">
            <summary>
            The data loaded to a Texture2D.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.IsClosedManually">
            <summary>
            True if the connection's stream will be closed manually. Used in custom protocols (WebSocket, EventSource).
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPResponse.GetHeaderValues(System.String)">
            <summary>
            Returns the list of values that received from the server for the given header name.
            <remarks>Remarks: All headers converted to lowercase while reading the response.</remarks>
            </summary>
            <param name="name">Name of the header</param>
            <returns>If no header found with the given name or there are no values in the list (eg. Count == 0) returns null.</returns>
        </member>
        <member name="M:BestHTTP.HTTPResponse.GetFirstHeaderValue(System.String)">
            <summary>
            Returns the first value in the header list or null if there are no header or value.
            </summary>
            <param name="name">Name of the header</param>
            <returns>If no header found with the given name or there are no values in the list (eg. Count == 0) returns null.</returns>
        </member>
        <member name="M:BestHTTP.HTTPResponse.HasHeaderWithValue(System.String,System.String)">
            <summary>
            Checks if there is a header with the given name and value.
            </summary>
            <param name="headerName">Name of the header.</param>
            <param name="value"></param>
            <returns>Returns true if there is a header with the given name and value.</returns>
        </member>
        <member name="M:BestHTTP.HTTPResponse.HasHeader(System.String)">
            <summary>
            Checks if there is a header with the given name.
            </summary>
            <param name="headerName">Name of the header.</param>
            <returns>Returns true if there is a header with the given name.</returns>
        </member>
        <member name="M:BestHTTP.HTTPResponse.GetRange">
            <summary>
            Parses the 'Content-Range' header's value and returns a HTTPRange object.
            </summary>
            <remarks>If the server ignores a byte-range-spec because it is syntactically invalid, the server SHOULD treat the request as if the invalid Range header field did not exist.
            (Normally, this means return a 200 response containing the full entity). In this case because of there are no 'Content-Range' header, this function will return null!</remarks>
            <returns>Returns null if no 'Content-Range' header found.</returns>
        </member>
        <member name="M:BestHTTP.HTTPResponse.FeedStreamFragment(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add data to the fragments list.
            </summary>
            <param name="buffer">The buffer to be added.</param>
            <param name="pos">The position where we start copy the data.</param>
            <param name="length">How many data we want to copy.</param>
        </member>
        <member name="M:BestHTTP.HTTPResponse.GetStreamedFragments">
            <summary>
            If streaming is used, then every time this callback function called we can use this function to
             retrieve the downloaded and buffered data. The returned list can be null, if there is no data yet.
            </summary>
            <returns></returns>
        </member>
        <member name="M:BestHTTP.HTTPResponse.Dispose">
            <summary>
            IDisposable implementation.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPUpdateDelegator">
            <summary>
            Will route some U3D calls to the HTTPManager.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPUpdateDelegator.Instance">
            <summary>
            The singleton instance of the HTTPUpdateDelegator
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPUpdateDelegator.IsCreated">
            <summary>
            True, if the Instance property should hold a valid value.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPUpdateDelegator.IsThreaded">
            <summary>
            Set it true before any CheckInstance() call, or before any request sent to dispatch callbacks on another thread.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPUpdateDelegator.IsThreadRunning">
            <summary>
            It's true if the dispatch thread running.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPUpdateDelegator.ThreadFrequencyInMS">
            <summary>
            How much time the plugin should wait between two update call. Its default value 100 ms.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPUpdateDelegator.OnBeforeApplicationQuit">
            <summary>
            Called in the OnApplicationQuit function. If this function returns False, the plugin will not start to
            shut down itself.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPUpdateDelegator.CheckInstance">
            <summary>
            Will create the HTTPUpdateDelegator instance and set it up.
            </summary>
        </member>
        <member name="T:BestHTTP.JSON.Json">
             <summary>
             Based on the download from http://techblog.procurios.nl/k/news/view/14605/14863/how-do-i-write-my-own-parser-%28for-json%29.html
             This class encodes and decodes JSON strings.
             Spec. details, see http://www.json.org/
            
             JSON uses Arrays and Objects. These correspond here to the datatypes List and Dictionary.
             All numbers are parsed to doubles.
             </summary>
        </member>
        <member name="M:BestHTTP.JSON.Json.Decode(System.String)">
            <summary>
            Parses the string json into a value
            </summary>
            <param name="json">A JSON string.</param>
            <returns>A List, a Dictionary, a double, a string, null, true, or false</returns>
        </member>
        <member name="M:BestHTTP.JSON.Json.Decode(System.String,System.Boolean@)">
            <summary>
            Parses the string json into a value; and fills 'success' with the successfullness of the parse.
            </summary>
            <param name="json">A JSON string.</param>
            <param name="success">Successful parse?</param>
            <returns>A List, a Dictionary, a double, a string, null, true, or false</returns>
        </member>
        <member name="M:BestHTTP.JSON.Json.Encode(System.Object)">
            <summary>
            Converts a Dictionary / List object into a JSON string
            </summary>
            <param name="json">A Dictionary / List</param>
            <returns>A JSON encoded string, or null if object 'json' is not serializable</returns>
        </member>
        <member name="T:BestHTTP.Logger.DefaultLogger">
            <summary>
            A basic logger implementation to be able to log intelligently additional informations about the plugin's internal mechanism.
            </summary>
        </member>
        <member name="T:BestHTTP.Logger.Loglevels">
            <summary>
            Available logging levels.
            </summary>
        </member>
        <member name="F:BestHTTP.Logger.Loglevels.All">
            <summary>
            All message will be logged.
            </summary>
        </member>
        <member name="F:BestHTTP.Logger.Loglevels.Information">
            <summary>
            Only Informations and above will be logged.
            </summary>
        </member>
        <member name="F:BestHTTP.Logger.Loglevels.Warning">
            <summary>
            Only Warnings and above will be logged.
            </summary>
        </member>
        <member name="F:BestHTTP.Logger.Loglevels.Error">
            <summary>
            Only Errors and above will be logged.
            </summary>
        </member>
        <member name="F:BestHTTP.Logger.Loglevels.Exception">
            <summary>
            Only Exceptions will be logged.
            </summary>
        </member>
        <member name="F:BestHTTP.Logger.Loglevels.None">
            <summary>
            No logging will be occur.
            </summary>
        </member>
        <member name="P:BestHTTP.Logger.ILogger.Level">
            <summary>
            The minimum severity to log
            </summary>
        </member>
        <member name="T:BestHTTP.ServerSentEvents.States">
            <summary>
            Possible states of an EventSource object.
            </summary>
        </member>
        <member name="T:BestHTTP.ServerSentEvents.EventSource">
            <summary>
            http://www.w3.org/TR/eventsource/
            </summary>
        </member>
        <member name="P:BestHTTP.ServerSentEvents.EventSource.Uri">
            <summary>
            Uri of the remote endpoint.
            </summary>
        </member>
        <member name="P:BestHTTP.ServerSentEvents.EventSource.State">
            <summary>
            Current state of the EventSource object.
            </summary>
        </member>
        <member name="P:BestHTTP.ServerSentEvents.EventSource.ReconnectionTime">
            <summary>
            Time to wait to do a reconnect attempt. Default to 2 sec. The server can overwrite this setting.
            </summary>
        </member>
        <member name="P:BestHTTP.ServerSentEvents.EventSource.LastEventId">
            <summary>
            The last successfully received event's id.
            </summary>
        </member>
        <member name="E:BestHTTP.ServerSentEvents.EventSource.OnOpen">
            <summary>
            Called when successfully connected to the server.
            </summary>
        </member>
        <member name="E:BestHTTP.ServerSentEvents.EventSource.OnMessage">
            <summary>
            Called on every message received from the server.
            </summary>
        </member>
        <member name="E:BestHTTP.ServerSentEvents.EventSource.OnError">
            <summary>
            Called when an error occures.
            </summary>
        </member>
        <member name="E:BestHTTP.ServerSentEvents.EventSource.OnClosed">
            <summary>
            Called when the EventSource object closed.
            </summary>
        </member>
        <member name="E:BestHTTP.ServerSentEvents.EventSource.OnStateChanged">
            <summary>
            Called every time when the State property changed.
            </summary>
        </member>
        <member name="F:BestHTTP.ServerSentEvents.EventSource.EventTable">
            <summary>
            A dictionary to store eventName => delegate mapping.
            </summary>
        </member>
        <member name="M:BestHTTP.ServerSentEvents.EventSource.Open">
            <summary>
            Start to connect to the remote servr.
            </summary>
        </member>
        <member name="M:BestHTTP.ServerSentEvents.EventSource.Close">
            <summary>
            Start to close the connection.
            </summary>
        </member>
        <member name="M:BestHTTP.ServerSentEvents.EventSource.On(System.String,BestHTTP.ServerSentEvents.OnEventDelegate)">
            <summary>
            With this function an event handler can be subscribed for an event name.
            </summary>
        </member>
        <member name="M:BestHTTP.ServerSentEvents.EventSource.Off(System.String)">
            <summary>
            With this function the event handler can be removed for the given event name.
            </summary>
            <param name="eventName"></param>
        </member>
        <member name="P:BestHTTP.ServerSentEvents.Message.Id">
            <summary>
            Event Id of the message. If it's null, then it's not present.
            </summary>
        </member>
        <member name="P:BestHTTP.ServerSentEvents.Message.Event">
            <summary>
            Name of the event, or an empty string.
            </summary>
        </member>
        <member name="P:BestHTTP.ServerSentEvents.Message.Data">
            <summary>
            The actual payload of the message.
            </summary>
        </member>
        <member name="P:BestHTTP.ServerSentEvents.Message.Retry">
            <summary>
            A reconnection time, in milliseconds. This must initially be a user-agent-defined value, probably in the region of a few seconds.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Authentication.IAuthenticationProvider.IsPreAuthRequired">
            <summary>
            The authentication must be run before any request made to build up the SignalR protocol
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Authentication.IAuthenticationProvider.OnAuthenticationSucceded">
            <summary>
            This event must be called when the pre-authentication succeded. When IsPreAuthRequired is false, no-one will subscribe to this event.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Authentication.IAuthenticationProvider.OnAuthenticationFailed">
            <summary>
            This event must be called when the pre-authentication failed. When IsPreAuthRequired is false, no-one will subscribe to this event.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Authentication.IAuthenticationProvider.StartAuthentication">
            <summary>
            This function called once, when the before the SignalR negotiation begins. If IsPreAuthRequired is false, then this step will be skipped.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Authentication.IAuthenticationProvider.PrepareRequest(BestHTTP.HTTPRequest,BestHTTP.SignalR.RequestTypes)">
            <summary>
            This function will be called for every request before sending it.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.IConnection">
            <summary>
            Interface to be able to hide internally used functions and properties.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.ProtocolVersions">
            <summary>
            Supported versions of the SignalR protocol.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Connection">
            <summary>
            The main SignalR class. This is the entry point to connect to a SignalR service.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.DefaultEncoder">
            <summary>
            The default Json encode/decoder that will be used to encode/decode the event arguments.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.Uri">
            <summary>
            The base url endpoint where the SignalR service can be found.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.State">
            <summary>
            Current State of the SignalR connection.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.NegotiationResult">
            <summary>
            Result of the negotiation request from the server.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.Hubs">
            <summary>
            The hubs that the client is connected to.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.Transport">
            <summary>
            The transport that is used to send and receive messages.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.Protocol">
            <summary>
            Current client protocol in use.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.AdditionalQueryParams">
            <summary>
            Additional query parameters that will be passed for the handshake uri. If the value is null, or an empty string it will be not appended to the query only the key.
            <remarks>The keys and values must be escaped properly, as the plugin will not escape these. </remarks>
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.QueryParamsOnlyForHandshake">
            <summary>
            If it's false, the parameters in the AdditionalQueryParams will be passed for all http requests. Its default value is true.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.JsonEncoder">
            <summary>
            The Json encoder that will be used by the connection and the transport.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.AuthenticationProvider">
            <summary>
            An IAuthenticationProvider implementation that will be used to authenticate the connection.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.PingInterval">
            <summary>
            How much time we have to wait between two pings.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.ReconnectDelay">
            <summary>
            Wait time before the plugin should do a reconnect attempt. Its default value is 5 seconds.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Connection.OnConnected">
            <summary>
            Called when the protocol is open for communication.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Connection.OnClosed">
            <summary>
            Called when the connection is closed, and no further messages are sent or received.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Connection.OnError">
            <summary>
            Called when an error occures. If the connection is already Started, it will try to do a reconnect, otherwise it will close the connection.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Connection.OnReconnecting">
            <summary>
            This event called when a reconnection attempt are started. If fails to reconnect an OnError and OnClosed events are called.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Connection.OnReconnected">
            <summary>
            This event called when the reconnection attempt succeded.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Connection.OnStateChanged">
            <summary>
            Called every time when the connection's state changes.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Connection.OnNonHubMessage">
            <summary>
            It's called when a non-Hub message received. The data can be anything from primitive types to array of complex objects.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.RequestPreparator">
            <summary>
            With this delegate all requests can be further customized.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.Item(System.Int32)">
            <summary>
            Indexer property the access hubs by index.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.Item(System.String)">
            <summary>
            Indexer property the access hubs by name.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.SyncRoot">
            <summary>
            An object to be able maintain thread safety.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.ClientMessageCounter">
            <summary>
            Unique ID for all message sent by the client.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.ClientProtocols">
            <summary>
            Supported client protocol versions.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.Timestamp">
            <summary>
            A timestamp that will be sent with all request for easier debugging.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.RequestCounter">
            <summary>
            Request counter sent with all request for easier debugging.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.LastReceivedMessage">
            <summary>
            Instance of the last received message. Used for its MessageId.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.GroupsToken">
            <summary>
            The GroupsToken sent by the server that stores what groups we are joined to.
            We will send it with the reconnect request.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.BufferedMessages">
            <summary>
            Received messages before the Start request finishes.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.LastMessageReceivedAt">
            <summary>
            When the last message received from the server. Used for reconnecting.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.ReconnectStartedAt">
            <summary>
            When we started to reconnect. When too much time passes without a successful reconnect, we will close the connection.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.ReconnectStarted">
            <summary>
            True, if the reconnect process started.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.LastPingSentAt">
            <summary>
            When the last ping request sent out.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.PingRequest">
            <summary>
            Reference to the ping request.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.TransportConnectionStartedAt">
            <summary>
            When the transport started the connection process
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.queryBuilder">
            <summary>
            Cached StringBuilder instance used in BuildUri
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.ConnectionData">
            <summary>
            Builds and returns with the connection data made from the hub names.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.BuiltConnectionData">
            <summary>
            The cached value of the result of the ConnectionData property call.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.QueryParams">
            <summary>
            Builds the keys and values from the AdditionalQueryParams to an key=value form. If AdditionalQueryParams is null or empty, it will return an empty string.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.BuiltQueryParams">
            <summary>
            The cached value of the result of the QueryParams property call.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.Open">
            <summary>
            This function will start to authenticate if required, and the SignalR protocol negotiation.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.OnAuthenticationSucceded(BestHTTP.SignalR.Authentication.IAuthenticationProvider)">
            <summary>
            Called when the authentication succeeded.
            </summary>
            <param name="provider"></param>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.OnAuthenticationFailed(BestHTTP.SignalR.Authentication.IAuthenticationProvider,System.String)">
            <summary>
            Called when the authentication failed.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.StartImpl">
            <summary>
            It's the real Start implementation. It will start the negotiation
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.OnNegotiationDataReceived(BestHTTP.SignalR.NegotiationData)">
            <summary>
            Protocol negotiation finished successfully.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.OnNegotiationError(BestHTTP.SignalR.NegotiationData,System.String)">
            <summary>
            Protocol negotiation failed.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.Close">
            <summary>
            Closes the connection and shuts down the transport.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.Reconnect">
            <summary>
            Initiates a reconnect to the SignalR server.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.Send(System.Object)">
            <summary>
            Will encode the argument to a Json string using the Connection's JsonEncoder, then will send it to the server.
            </summary>
            <returns>True if the plugin was able to send out the message</returns>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.SendJson(System.String)">
            <summary>
            Sends the given json string to the server.
            </summary>
            <returns>True if the plugin was able to send out the message</returns>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#SignalR#IConnection#OnMessage(BestHTTP.SignalR.Messages.IServerMessage)">
            <summary>
            Called when we receive a message from the server
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#SignalR#IConnection#TransportStarted">
            <summary>
            Called from the transport implementations when the Start request finishes successfully.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#SignalR#IConnection#TransportReconnected">
            <summary>
            Called when the transport sucessfully reconnected to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#SignalR#IConnection#TransportAborted">
            <summary>
            Called from the transport implementation when the Abort request finishes successfully.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#SignalR#IConnection#Error(System.String)">
            <summary>
            Called when an error occures. If the connection is in the Connected state, it will start the reconnect process, otherwise it will close the connection.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#SignalR#IConnection#BuildUri(BestHTTP.SignalR.RequestTypes)">
            <summary>
            Creates an Uri instance for the given request type.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#SignalR#IConnection#BuildUri(BestHTTP.SignalR.RequestTypes,BestHTTP.SignalR.Transports.TransportBase)">
            <summary>
            Creates an Uri instance from the given parameters.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#SignalR#IConnection#PrepareRequest(BestHTTP.HTTPRequest,BestHTTP.SignalR.RequestTypes)">
            <summary>
            It's called on every request before sending it out to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#SignalR#IConnection#ParseResponse(System.String)">
            <summary>
            Will parse a "{ 'Response': 'xyz' }" object and returns with 'xyz'. If it fails to parse, or getting the 'Response' key, it will call the Error function.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#Extensions#IHeartbeat#OnHeartbeatUpdate(System.TimeSpan)">
            <summary>
            IHeartbeat implementation to manage timeouts.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.InitOnStart">
            <summary>
            Init function to set the connected states and set up other variables.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.FindHub(System.UInt64)">
            <summary>
            Find and return with a Hub that has the message id.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.TryFallbackTransport">
            <summary>
            Try to fall back to next transport. If no more transport to try, it will return false.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.AdditionalQueryParams_CollectionChanged(System.Object,PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            This event will be called when the AdditonalQueryPrams dictionary changed. We have to reset the cached values.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.Ping">
            <summary>
            Sends a Ping request to the SignalR server.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.OnPingRequestFinished(BestHTTP.HTTPRequest,BestHTTP.HTTPResponse)">
            <summary>
            Called when the Ping request finished.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.TransportTypes">
            <summary>
            Possible transport types.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportTypes.WebSocket">
            <summary>
            Transport using WebSockets.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportTypes.ServerSentEvents">
            <summary>
            Transport using ServerSentEvents protocol.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportTypes.LongPoll">
            <summary>
            Transport using long-polling requests.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.MessageTypes">
            <summary>
            Server sent message types
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.MessageTypes.KeepAlive">
            <summary>
            An empty json object {} sent by the server to check keep alive.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.MessageTypes.Data">
            <summary>
            A no-hub message that contains data.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.MessageTypes.Multiple">
            <summary>
            A message that can hold multiple data message alongside with other information.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.MessageTypes.Result">
            <summary>
            A method call result.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.MessageTypes.Failure">
            <summary>
            A message about a failed method call.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.MessageTypes.MethodCall">
            <summary>
            A message with all information to be able to call a method on the client.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.MessageTypes.Progress">
            <summary>
            A long running server-method's progress.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.ConnectionStates">
            <summary>
            Possible SignalR Connection states.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.ConnectionStates.Initial">
            <summary>
            The initial state of the connection.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.ConnectionStates.Authenticating">
            <summary>
            The client authenticates itself with the server. This state is skipped if no AuthenticationProvider is present.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.ConnectionStates.Negotiating">
            <summary>
            The client sent out the negotiation request to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.ConnectionStates.Connecting">
            <summary>
            The client received the negotiation data, created the transport and wait's for the transport's connection.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.ConnectionStates.Connected">
            <summary>
            The transport connected and started successfully.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.ConnectionStates.Reconnecting">
            <summary>
            The client started the reconnect process.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.ConnectionStates.Closed">
            <summary>
            The connection is closed.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.RequestTypes">
            <summary>
            Possible types of SignalR requests.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.RequestTypes.Negotiate">
            <summary>
            Request to the /negotiate path to negotiate protocol parameters.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.RequestTypes.Connect">
            <summary>
            Request to the /connect path to connect to the server. With long-polling, it's like a regular poll request.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.RequestTypes.Start">
            <summary>
            Request to the /start path to start the protocol.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.RequestTypes.Poll">
            <summary>
            Request to the /poll path to get new messages. Not used with the WebSocketTransport.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.RequestTypes.Send">
            <summary>
            Request to the /send path to send a message to the server. Not used with the WebSocketTransport.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.RequestTypes.Reconnect">
            <summary>
            Request to the /reconnect path to initiate a reconnection. It's used instead of the Connect type.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.RequestTypes.Abort">
            <summary>
            Request to the /abort path to close the connection.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.RequestTypes.Ping">
            <summary>
            Request to the /ping path to ping the server keeping the asp.net session alive.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.TransportStates">
            <summary>
            Possible states of a transport.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportStates.Initial">
            <summary>
            Initial state
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportStates.Connecting">
            <summary>
            Connecting
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportStates.Reconnecting">
            <summary>
            Reconnecting
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportStates.Starting">
            <summary>
            Sending Start request
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportStates.Started">
            <summary>
            Start request finished successfully
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportStates.Closing">
            <summary>
            Sending Abort request
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportStates.Closed">
            <summary>
            The transport closed after Abort request sent
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Hubs.Hub">
            <summary>
            Represents a clientside Hub. This class can be used as a base class to encapsulate proxy functionalities.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Hubs.Hub.Name">
            <summary>
            Name of this hub.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Hubs.Hub.State">
            <summary>
            Server and user set state of the hub.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Hubs.Hub.OnMethodCall">
            <summary>
            Event called every time when the server sends an order to call a method on the client.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Hubs.Hub.SentMessages">
            <summary>
            Table of the sent messages. These messages will be removed from this table when a Result message is received from the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Hubs.Hub.MethodTable">
            <summary>
            Methodname -> callback delegate mapping. This table stores the server callable functions.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Hubs.Hub.builder">
            <summary>
            A reusable StringBuilder to save some GC allocs
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.On(System.String,BestHTTP.SignalR.Hubs.OnMethodCallCallbackDelegate)">
            <summary>
            Registers a callback function to the given method.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.Off(System.String)">
            <summary>
            Removes callback from the given method.
            </summary>
            <param name="method"></param>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.Call(System.String,System.Object[])">
            <summary>
            Orders the server to call a method with the given arguments.
            </summary>
            <returns>True if the plugin was able to send out the message</returns>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.Call(System.String,BestHTTP.SignalR.Hubs.OnMethodResultDelegate,System.Object[])">
            <summary>
            Orders the server to call a method with the given arguments.
            The onResult callback will be called when the server successfully called the function.
            </summary>
            <returns>True if the plugin was able to send out the message</returns>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.Call(System.String,BestHTTP.SignalR.Hubs.OnMethodResultDelegate,BestHTTP.SignalR.Hubs.OnMethodFailedDelegate,System.Object[])">
            <summary>
            Orders the server to call a method with the given arguments.
            The onResult callback will be called when the server successfully called the function.
            The onResultError will be called when the server can't call the function, or when the function throws an exception.
            </summary>
            <returns>True if the plugin was able to send out the message</returns>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.Call(System.String,BestHTTP.SignalR.Hubs.OnMethodResultDelegate,BestHTTP.SignalR.Hubs.OnMethodProgressDelegate,System.Object[])">
            <summary>
            Orders the server to call a method with the given arguments.
            The onResult callback will be called when the server successfully called the function.
            The onProgress callback called multiple times when the method is a long running function and reports back its progress.
            </summary>
            <returns>True if the plugin was able to send out the message</returns>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.Call(System.String,BestHTTP.SignalR.Hubs.OnMethodResultDelegate,BestHTTP.SignalR.Hubs.OnMethodFailedDelegate,BestHTTP.SignalR.Hubs.OnMethodProgressDelegate,System.Object[])">
            <summary>
            Orders the server to call a method with the given arguments.
            The onResult callback will be called when the server successfully called the function.
            The onResultError will be called when the server can't call the function, or when the function throws an exception.
            The onProgress callback called multiple times when the method is a long running function and reports back its progress.
            </summary>
            <returns>True if the plugin was able to send out the message</returns>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.BestHTTP#SignalR#Hubs#IHub#HasSentMessageId(System.UInt64)">
            <summary>
            Return true if this hub sent the message with the given id.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.BestHTTP#SignalR#Hubs#IHub#Close">
            <summary>
            Called on the manager's close.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.BestHTTP#SignalR#Hubs#IHub#OnMethod(BestHTTP.SignalR.Messages.MethodCallMessage)">
            <summary>
            Called when the client receives an order to call a hub-function.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.BestHTTP#SignalR#Hubs#IHub#OnMessage(BestHTTP.SignalR.Messages.IServerMessage)">
            <summary>
            Called when the client receives back messages as a result of a server method call.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.MergeState(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Merges the current and the new states.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.BuildMessage(BestHTTP.SignalR.Messages.ClientMessage)">
            <summary>
            Builds a JSon string from the given message.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Hubs.IHub">
            <summary>
            Interface to be able to hide internally used functions and properties.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.JsonEncoders.IJsonEncoder">
            <summary>
            Interface to be able to write custom Json encoders/decoders.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.JsonEncoders.IJsonEncoder.Encode(System.Object)">
            <summary>
            This function must create a json formatted string from the given object. If the encoding fails, it should return null.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.JsonEncoders.IJsonEncoder.DecodeMessage(System.String)">
            <summary>
            This function must create a dictionary the Json formatted string parameter. If the decoding fails, it should return null.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Messages.ClientMessage">
            <summary>
            This struct represents a message from the client.
            It holds every data and reference needed to construct the string represented message that will be sent to the wire.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Messages.ClientMessage.Hub">
            <summary>
            Reference to the source Hub. The Name and the State of the hub will be user.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Messages.ClientMessage.Method">
            <summary>
            Name of the method on the server to be called.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Messages.ClientMessage.Args">
            <summary>
            Arguments of the method.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Messages.ClientMessage.CallIdx">
            <summary>
            Unique id on the client of this message
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Messages.ClientMessage.ResultCallback">
            <summary>
            The delegate that will be called when the server will sends a result of this method call.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Messages.ClientMessage.ResultErrorCallback">
            <summary>
            The delegate that will be called when the server sends an error-result to this method call.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Messages.ClientMessage.ProgressCallback">
            <summary>
            The delegate that will be called when the server sends a progress message to this method call.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Messages.KeepAliveMessage">
            <summary>
            Keep-alive message sent by the server. No data sent with it.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Messages.MultiMessage">
            <summary>
            A message that may contains multiple sub-messages and additional informations.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MultiMessage.MessageId">
            <summary>
            Id of the sent message
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MultiMessage.IsInitialization">
            <summary>
            True if it's an initialization message, false otherwise.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MultiMessage.GroupsToken">
            <summary>
            Group token may be sent, if the group changed that the client belongs to.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MultiMessage.ShouldReconnect">
            <summary>
            The server suggests that the client should do a reconnect turn.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MultiMessage.PollDelay">
            <summary>
            Additional poll delay sent by the server.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MultiMessage.Data">
            <summary>
            List of server messages sent inside this message.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Messages.DataMessage">
            <summary>
            A simple non-hub data message. It holds only one Data property.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Messages.MethodCallMessage">
            <summary>
            A Hub message that orders the client to call a method.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MethodCallMessage.Hub">
            <summary>
            The name of the Hub that the method is called on.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MethodCallMessage.Method">
            <summary>
            Name of the Method.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MethodCallMessage.Arguments">
            <summary>
            Arguments of the method call.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MethodCallMessage.State">
            <summary>
            State changes of the hub. It's handled automatically by the Hub.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Messages.ResultMessage">
            <summary>
            Message of a server side method invocation result.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.ResultMessage.InvocationId">
            <summary>
            The unique id that the client set when called the server side method. Used by the plugin to deliver this message to the good Hub.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.ResultMessage.ReturnValue">
            <summary>
            The return value of the server side method call, or null if the method's return type is void.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.ResultMessage.State">
            <summary>
            State changes of the hub. It's handled automatically by the Hub.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.FailureMessage.InvocationId">
            <summary>
            The unique id that the client set when called the server side method. Used by the plugin to deliver this message to the good Hub.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.FailureMessage.IsHubError">
            <summary>
            True if it's a hub error.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.FailureMessage.ErrorMessage">
            <summary>
            If the method call failed, it contains the error message to detail what happened.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.FailureMessage.AdditionalData">
            <summary>
            A dictionary that may contain additional error data (can only be present for hub errors). It can be null.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.FailureMessage.StackTrace">
            <summary>
            Stack trace of the error. It present only if detailed error reporting is turned on on the server (https://msdn.microsoft.com/en-us/library/microsoft.aspnet.signalr.hubconfiguration.enabledetailederrors%28v=vs.118%29.aspx).
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.FailureMessage.State">
            <summary>
            State changes of the hub. It's handled automatically by the Hub.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Messages.ProgressMessage">
            <summary>
            When a server method is a long running method the server can send the information about the progress of execution of the method to the client.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.ProgressMessage.InvocationId">
            <summary>
            The unique id that the client set when called the server side method. Used by the plugin to deliver this message to the good Hub.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.ProgressMessage.Progress">
            <summary>
            Current progress of the long running method.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.Url">
            <summary>
            Path to the SignalR endpoint. Currently not used by the client.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.WebSocketServerUrl">
            <summary>
            WebSocket endpoint.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.ConnectionToken">
            <summary>
            Connection token assigned by the server. See this article for more details: http://www.asp.net/signalr/overview/security/introduction-to-security#connectiontoken.
            This value needs to be sent in each subsequent request as the value of the connectionToken parameter
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.ConnectionId">
            <summary>
            The id of the connection.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.KeepAliveTimeout">
            <summary>
            The amount of time in seconds the client should wait before attempting to reconnect if it has not received a keep alive message.
            If the server is configured to not send keep alive messages this value is null.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.DisconnectTimeout">
            <summary>
            The amount of time within which the client should try to reconnect if the connection goes away.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.ConnectionTimeout">
            <summary>
            Timeout of poll requests.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.TryWebSockets">
            <summary>
            Whether the server supports websockets.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.ProtocolVersion">
            <summary>
            The version of the protocol used for communication.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.TransportConnectTimeout">
            <summary>
            The maximum amount of time the client should try to connect to the server using a given transport.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.LongPollDelay">
            <summary>
            The wait time before restablishing a long poll connection after data is sent from the server. The default value is 0.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.NegotiationData.OnReceived">
            <summary>
            Event handler that called when the negotiation data received and parsed successfully.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.NegotiationData.OnError">
            <summary>
            Event handler that called when an error happens.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.NegotiationData.Start">
            <summary>
            Start to get the negotiation data.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.NegotiationData.Abort">
            <summary>
            Abort the negotiation request.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Transports.PollingTransport.LastPoll">
            <summary>
            When we received the last poll.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Transports.PollingTransport.PollDelay">
            <summary>
            How much time we have to wait before we can send out a new poll request. This value sent by the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Transports.PollingTransport.PollTimeout">
            <summary>
            How much time we wait to a poll request to finish. It's value is the server sent negotiation's ConnectionTimeout + 10sec.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Transports.PollingTransport.pollRequest">
            <summary>
            Reference to the the current poll request.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.PollingTransport.Connect">
            <summary>
            Polling transport specific connection logic. It's a regular GET request to the /connect path.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.PollingTransport.Poll">
            <summary>
            Polling transport speficic function. Sends a GET request to the /poll path to receive messages.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Transports.PostSendTransportBase">
            <summary>
            A base class for implementations that must send the data in unique requests. These are currently the LongPolling and ServerSentEvents transports.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Transports.PostSendTransportBase.sendRequestQueue">
            <summary>
            Sent out send requests. Keeping a reference to them for future use.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Transports.ServerSentEventsTransport">
            <summary>
            A SignalR transport implementation that uses the Server-Sent Events protocol.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Transports.ServerSentEventsTransport.SupportsKeepAlive">
            <summary>
            It's a persistent connection. We support the keep-alive mechanism.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Transports.ServerSentEventsTransport.Type">
            <summary>
            Type of the transport.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Transports.ServerSentEventsTransport.EventSource">
            <summary>
            The EventSource object.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.ServerSentEventsTransport.Abort">
            <summary>
            A custom Abort function where we will start to close the EventSource object.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Transports.TransportBase.Name">
            <summary>
            Name of the transport.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Transports.TransportBase.SupportsKeepAlive">
            <summary>
            True if the manager has to check the last message received time and reconnect if too much time passes.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Transports.TransportBase.Type">
            <summary>
            Type of the transport. Used mainly by the manager in its BuildUri function.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Transports.TransportBase.Connection">
            <summary>
            Reference to the manager.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Transports.TransportBase.State">
            <summary>
            The current state of the transport.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Transports.TransportBase.OnStateChanged">
            <summary>
            Thi event called when the transport's State set to a new value.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.Connect">
            <summary>
            Start to connect to the server
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.Stop">
            <summary>
            Stop the connection
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.SendImpl(System.String)">
            <summary>
            The transport specific implementation to send the given json string to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.Started">
            <summary>
            Called when the Start request finished successfully, or after a reconnect.
            Manager.TransportOpened(); called from the TransportBase after this call
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.Aborted">
            <summary>
            Called when the abort request finished successfully.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.OnConnected">
            <summary>
            Called after a succesful connect/reconnect. The transport implementations have to call this function.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.Start">
            <summary>
            Sends out the /start request to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.Abort">
            <summary>
            Will abort the transport. In SignalR 'Abort'ing is a graceful process, while 'Close'ing is a hard-abortion...
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.Send(System.String)">
            <summary>
            Sends the given json string to the wire.
            </summary>
            <param name="jsonStr"></param>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.Reconnect">
            <summary>
            Start the reconnect process
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.Parse(BestHTTP.SignalR.JsonEncoders.IJsonEncoder,System.String)">
            <summary>
            When the json string is successfully parsed will return with an IServerMessage implementation.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.WebSocketTransport.Connect">
            <summary>
            Websocket transport specific connection logic. It will create a WebSocket instance, and starts to connect to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.WebSocketTransport.Aborted">
            <summary>
            The /abort request successfully finished
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.TransportEventTypes">
            <summary>
            Possible event types on the transport level.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.SocketIOEventTypes">
            <summary>
            Event types of the SocketIO protocol.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.Connect">
            <summary>
            Connect to a namespace, or we connected to a namespace
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.Disconnect">
            <summary>
            Disconnect a namespace, or we disconnected from a namespace.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.Event">
            <summary>
            A general event. The event's name is in the payload.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.Ack">
            <summary>
            Acknowledgment of an event.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.Error">
            <summary>
            Error sent by the server, or by the plugin
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.BinaryEvent">
            <summary>
            A general event with binary attached to the packet. The event's name is in the payload.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.BinaryAck">
            <summary>
            Acknowledgment of a binary event.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.SocketIOErrors">
            <summary>
            Possible error codes that the SocketIO server can send.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.UnknownTransport">
            <summary>
            Transport unknown
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.UnknownSid">
            <summary>
            Session ID unknown
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.BadHandshakeMethod">
            <summary>
            Bad handshake method
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.BadRequest">
            <summary>
            Bad request
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.Internal">
            <summary>
            Plugin internal error!
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.User">
            <summary>
            Exceptions that caught by the plugin but raised in a user code.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.Custom">
            <summary>
            A custom, server sent error, most probably from a Socket.IO middleware.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Events.EventDescriptor">
            <summary>
            A class to describe an event, and its metadatas.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Events.EventDescriptor.Callbacks">
            <summary>
            List of callback delegates.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Events.EventDescriptor.OnlyOnce">
            <summary>
            If this property is true, callbacks are removed automatically after the event dispatch.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Events.EventDescriptor.AutoDecodePayload">
            <summary>
            If this property is true, the dispatching packet's Payload will be decoded using the Manager's Encoder.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Events.EventDescriptor.CallbackArray">
            <summary>
            Cache an array on a hot-path.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventDescriptor.#ctor(System.Boolean,System.Boolean,BestHTTP.SocketIO.Events.SocketIOCallback)">
            <summary>
            Constructor to create an EventDescriptor instance and set the meta-datas.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventDescriptor.Call(BestHTTP.SocketIO.Socket,BestHTTP.SocketIO.Packet,System.Object[])">
            <summary>
            Will call the callback delegates with the given parameters and remove the callbacks if this descriptor marked with a true OnlyOnce property.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Events.EventNames">
            <summary>
            Helper class to provide functions to an easy Enum->string conversation of the transport and SocketIO evenet types.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventNames.IsBlacklisted(System.String)">
            <summary>
            Checks an event name whether it's blacklisted or not.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Events.EventTable">
            <summary>
            This class helps keep track and maintain EventDescriptor instances and dispatching packets to the right delegates.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Events.EventTable.Socket">
            <summary>
            The Socket that this EventTable is bound to.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Events.EventTable.Table">
            <summary>
            The 'EventName -> List of events' mapping.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.#ctor(BestHTTP.SocketIO.Socket)">
            <summary>
            Constructor to create an instance and bind it to a socket.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.Register(System.String,BestHTTP.SocketIO.Events.SocketIOCallback,System.Boolean,System.Boolean)">
            <summary>
            Register a callback to a name with the given metadata.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.Unregister(System.String)">
            <summary>
            Removes all events that registered for the given name.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.Unregister(System.String,BestHTTP.SocketIO.Events.SocketIOCallback)">
            <summary>
            
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.Call(System.String,BestHTTP.SocketIO.Packet,System.Object[])">
            <summary>
            Will call the delegates that associated to the given eventName.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.Call(BestHTTP.SocketIO.Packet)">
            <summary>
            This function will get the eventName from the packet's Payload, and optionally will decode it from Json.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.Clear">
            <summary>
            Remove all event -> delegate association.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.ShouldDecodePayload(System.String)">
            <summary>
            Returns true, if for the given event name there are at least one event that needs a decoded 
            </summary>
            <param name="eventName"></param>
            <returns></returns>
        </member>
        <member name="T:BestHTTP.SocketIO.HandshakeData">
            <summary>
            Helper class to parse and hold handshake information.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.HandshakeData.Sid">
            <summary>
            Session ID of this connection.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.HandshakeData.Upgrades">
            <summary>
            List of possible upgrades.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.HandshakeData.PingInterval">
            <summary>
            What interval we have to set a ping message.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.HandshakeData.PingTimeout">
            <summary>
            What time have to pass without an answer to our ping request when we can consider the connection disconnected.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.IManager">
            <summary>
            Interface to hide internal functions from the user by implementing it as an explicit interface.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.ISocket">
            <summary>
            Interface to hide internal functions from the user by implementing it as an explicit interface.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.JsonEncoders.DefaultJSonEncoder">
            <summary>
            The default IJsonEncoder implementation. It's uses the Json class from the BestHTTP.JSON namespace to encode and decode.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.JsonEncoders.IJsonEncoder">
            <summary>
            Interface to be able to write custom Json encoders/decoders.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.JsonEncoders.IJsonEncoder.Decode(System.String)">
            <summary>
            The Decode function must create a list of objects from the Json formatted string parameter. If the decoding fails, it should return null.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.JsonEncoders.IJsonEncoder.Encode(System.Collections.Generic.List{System.Object})">
            <summary>
            The Encode function must create a json formatted string from the parameter. If the encoding fails, it should return null.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.TransportEvent">
            <summary>
            Event type of this packet on the transport layer.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.SocketIOEvent">
            <summary>
            The packet's type in the Socket.IO protocol.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.AttachmentCount">
            <summary>
            How many attachment should have this packet.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.Id">
            <summary>
            The internal ack-id of this packet.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.Namespace">
            <summary>
            The sender namespace's name.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.Payload">
            <summary>
            The payload as a Json string.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.EventName">
            <summary>
            The decoded event name from the payload string.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.Attachments">
            <summary>
            All binary data attached to this event.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.HasAllAttachment">
            <summary>
            Property to check whether all attachments are received to this packet.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.IsDecoded">
            <summary>
            True if it's already decoded. The DecodedArgs still can be null after the Decode call.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.DecodedArgs">
            <summary>
            The decoded arguments from the result of a Json string -> c# object convert.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.#ctor">
            <summary>
            Internal constructor. Don't use it directly!
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.#ctor(System.String)">
            <summary>
            Internal constructor. Don't use it directly!
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.#ctor(BestHTTP.SocketIO.TransportEventTypes,BestHTTP.SocketIO.SocketIOEventTypes,System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Internal constructor. Don't use it directly!
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.DecodeEventName">
            <summary>
            Will set and return with the EventName from the packet's Payload string.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.ReconstructAttachmentAsIndex">
            <summary>
            Will switch the "{'_placeholder':true,'num':X}" to a the index num X.
            </summary>
            <returns>True if successfully reconstructed, false otherwise.</returns>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.ReconstructAttachmentAsBase64">
            <summary>
            Will switch the "{'_placeholder':true,'num':X}" to a the data as a base64 encoded string.
            </summary>
            <returns>True if successfully reconstructed, false otherwise.</returns>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.Parse(System.String)">
            <summary>
            Parse the packet from a server sent textual data. The Payload will be the raw json string.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.Encode">
            <summary>
            Encodes this packet to a Socket.IO formatted string.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.EncodeBinary">
            <summary>
            Encodes this packet to a Socket.IO formatted byte array.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.AddAttachmentFromServer(System.Byte[],System.Boolean)">
            <summary>
            Will add the byte[] that the server sent to the attachments list.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.EncodeData(System.Byte[],BestHTTP.SocketIO.Packet.PayloadTypes,System.Byte[])">
            <summary>
            Encodes a byte array to a Socket.IO binary encoded message
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.PlaceholderReplacer(System.Action{System.String,System.Collections.Generic.Dictionary{System.String,System.Object}})">
            <summary>
            Searches for the "{'_placeholder':true,'num':X}" string, and will call the given action to modify the PayLoad
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.ToString">
            <summary>
            Returns with the Payload of this packet.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.Clone">
            <summary>
            Will clone this packet to an identical packet instance.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Socket">
            <summary>
            This class represents a Socket.IO namespace.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Socket.Manager">
            <summary>
            The SocketManager instance that created this socket.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Socket.Namespace">
            <summary>
            The namespace that this socket is bound to.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Socket.IsOpen">
            <summary>
            True if the socket is connected and open to the server. False otherwise.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Socket.AutoDecodePayload">
            <summary>
            While this property is True, the socket will decode the Packet's Payload data using the parent SocketManager's Encoder. You must set this property before any event subscription! Its default value is True;
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Socket.AckCallbacks">
            <summary>
            A table to store acknowledgment callbacks associated to the given ids.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Socket.EventCallbacks">
            <summary>
            Tha callback table that helps this class to manage event subscription and dispatching events.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Socket.arguments">
            <summary>
            Cached list to spare some GC alloc.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.#ctor(System.String,BestHTTP.SocketIO.SocketManager)">
            <summary>
            Internal constructor.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.BestHTTP#SocketIO#ISocket#Open">
            <summary>
            Internal function to start opening the socket.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.Disconnect">
            <summary>
            Disconnects this socket/namespace.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.BestHTTP#SocketIO#ISocket#Disconnect(System.Boolean)">
            <summary>
            Disconnects this socket/namespace.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.On(System.String,BestHTTP.SocketIO.Events.SocketIOCallback)">
            <summary>
            Register a callback for a given name
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.Off">
            <summary>
            Remove all callbacks for all events.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.Off(System.String)">
            <summary>
            Removes all callbacks to the given event.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.Off(BestHTTP.SocketIO.SocketIOEventTypes)">
            <summary>
            Removes all callbacks to the given event.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.Off(System.String,BestHTTP.SocketIO.Events.SocketIOCallback)">
            <summary>
            Remove the specified callback.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.Off(BestHTTP.SocketIO.SocketIOEventTypes,BestHTTP.SocketIO.Events.SocketIOCallback)">
            <summary>
            Remove the specified callback.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.BestHTTP#SocketIO#ISocket#OnPacket(BestHTTP.SocketIO.Packet)">
            <summary>
            Last call of the OnPacket chain(Transport -> Manager -> Socket), we will dispatch the event if there is any callback
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.BestHTTP#SocketIO#ISocket#EmitEvent(BestHTTP.SocketIO.SocketIOEventTypes,System.Object[])">
            <summary>
            Emits an internal packet-less event to the user level.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.BestHTTP#SocketIO#ISocket#EmitEvent(System.String,System.Object[])">
            <summary>
            Emits an internal packet-less event to the user level.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.OnTransportOpen(BestHTTP.SocketIO.Socket,BestHTTP.SocketIO.Packet,System.Object[])">
            <summary>
            Called when a "connect" event received to the root namespace
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.SocketManager.States">
            <summary>
            Possible states of a SocketManager instance.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.States.Initial">
            <summary>
            Initial state of the SocketManager
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.States.Closed">
            <summary>
            The SocketManager is closed, initiated by the user or by the server
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.States.Opening">
            <summary>
            The SocketManager is currently opening.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.States.Open">
            <summary>
            The SocketManager is open, events can be sent to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.States.Paused">
            <summary>
            Paused for transport upgrade
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.States.Reconnecting">
            <summary>
            An error occurred, the SocketManager now trying to connect again to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.DefaultEncoder">
            <summary>
            The default Json encode/decoder that will be used to encode/decode the event arguments.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.MinProtocolVersion">
            <summary>
            Supported Socket.IO protocol version
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.State">
            <summary>
            The current state of this Socket.IO manager.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Options">
            <summary>
            The SocketOptions instance that this manager will use.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Uri">
            <summary>
            The Uri to the Socket.IO endpoint.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Handshake">
            <summary>
            The server sent and parsed Handshake data.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Transport">
            <summary>
            The currently used main transport instance.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.RequestCounter">
            <summary>
            The Request counter for request-based transports.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Socket">
            <summary>
            The root("/") Socket.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Item(System.String)">
            <summary>
            Indexer to access socket associated to the given namespace.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.ReconnectAttempts">
            <summary>
            How many reconnect attempts made.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Encoder">
            <summary>
            The JSon encoder that will be used to encode the sent data to json and decode the received json to an object list.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Timestamp">
            <summary>
            Timestamp support to the request based transports.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.NextAckId">
            <summary>
            Auto-incrementing property to return Ack ids.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.PreviousState">
            <summary>
            Internal property to store the previous state of the manager.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.UpgradingTransport">
            <summary>
            Transport currently upgrading.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.Namespaces">
            <summary>
            Namespace name -> Socket mapping
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.Sockets">
            <summary>
            List of the sockets to able to iterate over them easily.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.OfflinePackets">
            <summary>
            List of unsent packets. Only instantiated when we have to use it.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.LastHeartbeat">
            <summary>
            When we sent out the last heartbeat(Ping) message.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.LastPongReceived">
            <summary>
            When we received the last Pong message answering to our heartbeat(Ping) message.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.ReconnectAt">
            <summary>
            When we have to try to do a reconnect attempt
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.ConnectionStarted">
            <summary>
            When we started to connect to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.closing">
            <summary>
            Private flag to avoid multiple Close call
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.#ctor(System.Uri)">
            <summary>
            Constructor to create a SocketManager instance that will connect to the given uri.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.#ctor(System.Uri,BestHTTP.SocketIO.SocketOptions)">
            <summary>
            Constructor to create a SocketManager instance.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.GetSocket">
            <summary>
            Returns with the "/" namespace, the same as the Socket property.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.GetSocket(System.String)">
            <summary>
            Returns with the specified namespace
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#Remove(BestHTTP.SocketIO.Socket)">
            <summary>
            Internal function to remove a Socket instance from this manager.
            </summary>
            <param name="socket"></param>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.Open">
            <summary>
            This function will begin to open the Socket.IO connection by sending out the handshake request.
            If the Options' AutoConnect is true, it will be called automatically.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.Close">
            <summary>
            Closes this Socket.IO connection.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#Close(System.Boolean)">
            <summary>
            Closes this Socket.IO connection.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#TryToReconnect">
            <summary>
            Called from a ITransport implementation when an error occurs and we may have to try to reconnect.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#OnTransportConnected(BestHTTP.SocketIO.Transports.ITransport)">
            <summary>
            Called by transports when they are connected to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.SelectTransport">
            <summary>
            Select the best transport to send out packets.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.SendOfflinePackets">
            <summary>
            Will select the best transport and sends out all packets that are in the OfflinePackets list.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#SendPacket(BestHTTP.SocketIO.Packet)">
            <summary>
            Internal function that called from the Socket class. It will send out the packet instantly, or if no transport is available it will store
            the packet in the OfflinePackets list.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#OnPacket(BestHTTP.SocketIO.Packet)">
            <summary>
            Called from the currently operating Transport. Will pass forward to the Socket that has to call the callbacks.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.EmitAll(System.String,System.Object[])">
            <summary>
            Sends an event to all available namespaces.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#EmitEvent(System.String,System.Object[])">
            <summary>
            Emits an internal packet-less event to the root namespace without creating it if it isn't exists yet.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#EmitEvent(BestHTTP.SocketIO.SocketIOEventTypes,System.Object[])">
            <summary>
            Emits an internal packet-less event to the root namespace without creating it if it isn't exists yet.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#Extensions#IHeartbeat#OnHeartbeatUpdate(System.TimeSpan)">
            <summary>
            Called from the HTTPManager's OnUpdate function every frame. It's main function is to send out heartbeat messages.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.ConnectWith">
            <summary>
            The SocketManager will try to connect with this transport.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.Reconnection">
            <summary>
            Whether to reconnect automatically after a disconnect (default true)
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.ReconnectionAttempts">
            <summary>
            Number of attempts before giving up (default Int.MaxValue)
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.ReconnectionDelay">
            <summary>
            How long to initially wait before attempting a new reconnection (default 1000ms).
            Affected by +/- RandomizationFactor, for example the default initial delay will be between 500ms to 1500ms.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.ReconnectionDelayMax">
            <summary>
            Maximum amount of time to wait between reconnections (default 5000ms).
            Each attempt increases the reconnection delay along with a randomization as above.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.RandomizationFactor">
            <summary>
            (default 0.5`), [0..1]
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.Timeout">
            <summary>
            Connection timeout before a connect_error and connect_timeout events are emitted (default 20000ms)
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.AutoConnect">
            <summary>
            By setting this false, you have to call SocketManager's Open() whenever you decide it's appropriate.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.AdditionalQueryParams">
            <summary>
            Additional query parameters that will be passed for the handshake uri. If the value is null, or an empty string it will be not appended to the query only the key.
            <remarks>The keys and values must be escaped properly, as the plugin will not escape these. </remarks>
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.QueryParamsOnlyForHandshake">
            <summary>
            If it's false, the parameters in the AdditionalQueryParams will be passed for all HTTP requests. Its default value is true.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketOptions.BuiltQueryParams">
            <summary>
            The cached value of the result of the BuildQueryParams() call.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketOptions.#ctor">
            <summary>
            Constructor, setting the default option values.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketOptions.BuildQueryParams">
            <summary>
            Builds the keys and values from the AdditionalQueryParams to an key=value form. If AdditionalQueryParams is null or empty, it will return an empty string.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketOptions.AdditionalQueryParams_CollectionChanged(System.Object,PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            This event will be called when the AdditonalQueryPrams dictionary changed. We have to reset the cached values.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Transports.TransportStates">
            <summary>
            Possible states of an ITransport implementation.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.TransportStates.Connecting">
            <summary>
            The transport is connecting to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.TransportStates.Opening">
            <summary>
            The transport is connected, and started the opening process.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.TransportStates.Open">
            <summary>
            The transport is open, can send and receive packets.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.TransportStates.Closed">
            <summary>
            The transport is closed.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.TransportStates.Paused">
            <summary>
            The transport is paused.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Transports.ITransport">
            <summary>
            An interface that a Socket.IO transport must implement.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Transports.ITransport.Type">
            <summary>
            Type of this transport.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Transports.ITransport.State">
            <summary>
            Current state of the transport
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Transports.ITransport.Manager">
            <summary>
            SocketManager instance that this transport is bound to.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Transports.ITransport.IsRequestInProgress">
            <summary>
            True if the transport is busy with sending messages.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Transports.ITransport.IsPollingInProgress">
            <summary>
            True if the transport is busy with a poll request.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.ITransport.Open">
            <summary>
            Start open/upgrade the transport.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.ITransport.Poll">
            <summary>
            Do a poll for available messages on the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.ITransport.Send(BestHTTP.SocketIO.Packet)">
            <summary>
            Send a single packet to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.ITransport.Send(System.Collections.Generic.List{BestHTTP.SocketIO.Packet})">
            <summary>
            Send a list of packets to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.ITransport.Close">
            <summary>
            Close this transport.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.PollingTransport.LastRequest">
            <summary>
            The last POST request we sent to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.PollingTransport.PollRequest">
            <summary>
            Last GET request we sent to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.PollingTransport.PacketWithAttachment">
            <summary>
            The last packet with expected binary attachments
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.PollingTransport.Close">
            <summary>
            Closes the transport and cleans up resources.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.PollingTransport.OnPacket(BestHTTP.SocketIO.Packet)">
            <summary>
            Preprocessing and sending out packets to the manager.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.PollingTransport.ParseResponse(BestHTTP.HTTPResponse)">
            <summary>
            Will parse the response, and send out the parsed packets.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Transports.WebSocketTransport">
            <summary>
            A transport implementation that can communicate with a SocketIO server.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.Close">
            <summary>
            Closes the transport and cleans up resources.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.Poll">
            <summary>
            Polling implementation. With WebSocket it's just a skeleton.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.OnOpen(BestHTTP.WebSocket.WebSocket)">
            <summary>
            WebSocket implementation OnOpen event handler.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.OnMessage(BestHTTP.WebSocket.WebSocket,System.String)">
            <summary>
            WebSocket implementation OnMessage event handler.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.OnBinary(BestHTTP.WebSocket.WebSocket,System.Byte[])">
            <summary>
            WebSocket implementation OnBinary event handler.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.OnError(BestHTTP.WebSocket.WebSocket,System.Exception)">
            <summary>
            WebSocket implementation OnError event handler.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.OnClosed(BestHTTP.WebSocket.WebSocket,System.UInt16,System.String)">
            <summary>
            WebSocket implementation OnClosed event handler.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.Send(BestHTTP.SocketIO.Packet)">
            <summary>
            A WebSocket implementation of the packet sending.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.Send(System.Collections.Generic.List{BestHTTP.SocketIO.Packet})">
            <summary>
            A WebSocket implementation of the packet sending.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.OnPacket(BestHTTP.SocketIO.Packet)">
            <summary>
            Will only process packets that need to upgrade. All other packets are passed to the Manager.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.StatisticsQueryFlags.Connections">
            <summary>
            Connection based statistics will be returned as the result of the query.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.StatisticsQueryFlags.Cache">
            <summary>
            Caching based statistics will be returned as the result of the query.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.StatisticsQueryFlags.Cookies">
            <summary>
            Cookie based statistics will be returned as the result of the query.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.StatisticsQueryFlags.All">
            <summary>
            All statistics will be returned as the result of the query.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.Connections">
            <summary>
            Number of HTTPConnection instances
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.ActiveConnections">
            <summary>
            Number of active connections. These connections are currently processing a request.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.FreeConnections">
            <summary>
            Number of free connections. These connections are finished with there requests and waiting for another request or to recycle.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.RecycledConnections">
            <summary>
            Number of recycled connections. These connections will be removed as soon as possible.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.RequestsInQueue">
            <summary>
            Number of requests that are waiting in the queue for a free connection.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.CacheEntityCount">
            <summary>
            Number of cached responses.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.CacheSize">
            <summary>
            Sum size of the cached responses in bytes.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.CookieCount">
            <summary>
            Number of cookies in the Cookie Jar.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.CookieJarSize">
            <summary>
            Sum size of the stored cookies in bytes.
            </summary>
        </member>
        <member name="T:BestHTTP.WebSocket.WebSocketStates">
            <summary>
            States of the underlying browser's WebSocket implementation's state. It's available only in WebGL builds.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.WebSocket.IsOpen">
            <summary>
            The connection to the WebSocket server is open.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnOpen">
            <summary>
            Called when the connection to the WebSocket server is established.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnMessage">
            <summary>
            Called when a new textual message is received from the server.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnBinary">
            <summary>
            Called when a new binary message is received from the server.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnClosed">
            <summary>
            Called when the WebSocket connection is closed.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnError">
            <summary>
            Called when an error is encountered. The Exception parameter may be null.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnErrorDesc">
            <summary>
            Called when an error is encountered. The parameter will be the description of the error.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.#ctor(System.Uri)">
            <summary>
            Creates a WebSocket instance from the given uri.
            </summary>
            <param name="uri">The uri of the WebSocket server</param>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.#ctor(System.Uri,System.String,System.String)">
            <summary>
            Creates a WebSocket instance from the given uri, protocol and origin.
            </summary>
            <param name="uri">The uri of the WebSocket server</param>
            <param name="origin">Servers that are not intended to process input from any web page but only for certain sites SHOULD verify the |Origin| field is an origin they expect.
            If the origin indicated is unacceptable to the server, then it SHOULD respond to the WebSocket handshake with a reply containing HTTP 403 Forbidden status code.</param>
            <param name="protocol">The application-level protocol that the client want to use(eg. "chat", "leaderboard", etc.). Can be null or empty string if not used.</param>
            <param name="extensions">Optional IExtensions implementations</param>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Open">
            <summary>
            Start the opening process.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Send(System.String)">
            <summary>
            It will send the given message to the server in one frame.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Send(System.Byte[])">
            <summary>
            It will send the given data to the server in one frame.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Send(System.Byte[],System.UInt64,System.UInt64)">
            <summary>
            Will send count bytes from a byte array, starting from offset.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Close">
            <summary>
            It will initiate the closing of the connection to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Close(System.UInt16,System.String)">
            <summary>
            It will initiate the closing of the connection to the server sending the given code and message.
            </summary>
        </member>
        <member name="T:BestHTTP.WebSocket.WebSocketStausCodes">
            <summary>
            http://tools.ietf.org/html/rfc6455#section-7.4.1
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.NormalClosure">
            <summary>
            Indicates a normal closure, meaning that the purpose for which the connection was established has been fulfilled.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.GoingAway">
            <summary>
            Indicates that an endpoint is "going away", such as a server going down or a browser having navigated away from a page.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.ProtocolError">
            <summary>
            Indicates that an endpoint is terminating the connection due to a protocol error.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.WrongDataType">
            <summary>
            Indicates that an endpoint is terminating the connection because it has received a type of data it cannot accept
            (e.g., an endpoint that understands only text data MAY send this if it receives a binary message).
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.Reserved">
            <summary>
            Reserved. The specific meaning might be defined in the future.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.NoStatusCode">
            <summary>
            A reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint.
            It is designated for use in applications expecting a status code to indicate that no status code was actually present.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.ClosedAbnormally">
            <summary>
            A reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint.
            It is designated for use in applications expecting a status code to indicate that the connection was closed abnormally, e.g., without sending or receiving a Close control frame.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.DataError">
            <summary>
            Indicates that an endpoint is terminating the connection because it has received data within a message that was not consistent with the type of the message (e.g., non-UTF-8 [RFC3629] data within a text message).
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.PolicyError">
            <summary>
            Indicates that an endpoint is terminating the connection because it has received a message that violates its policy.
            This is a generic status code that can be returned when there is no other more suitable status code (e.g., 1003 or 1009) or if there is a need to hide specific details about the policy.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.TooBigMessage">
            <summary>
            Indicates that an endpoint is terminating the connection because it has received a message that is too big for it to process.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.ExtensionExpected">
            <summary>
            Indicates that an endpoint (client) is terminating the connection because it has expected the server to negotiate one or more extension, 
            but the server didn't return them in the response message of the WebSocket handshake.
            The list of extensions that are needed SHOULD appear in the /reason/ part of the Close frame. Note that this status code is not used by the server, because it can fail the WebSocket handshake instead.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.WrongRequest">
            <summary>
            Indicates that a server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.TLSHandshakeError">
            <summary>
            A reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint.  It is designated for use in applications expecting a status code to indicate that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified).
            </summary>
        </member>
        <member name="T:PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction">
            <summary>
            This enum describes the action that caused a CollectionChanged event.
            </summary>
        </member>
        <member name="F:PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction.Add">
            <summary> One or more items were added to the collection. </summary>
        </member>
        <member name="F:PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction.Remove">
            <summary> One or more items were removed from the collection. </summary>
        </member>
        <member name="F:PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction.Replace">
            <summary> One or more items were replaced in the collection. </summary>
        </member>
        <member name="F:PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction.Move">
            <summary> One or more items were moved within the collection. </summary>
        </member>
        <member name="F:PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction.Reset">
            <summary> The contents of the collection changed dramatically. </summary>
        </member>
        <member name="T:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs">
            <summary>
            Arguments for the CollectionChanged event.
            A collection that supports INotifyCollectionChangedThis raises this event
            whenever an item is added or removed, or when the contents of the collection
            changes dramatically.
            </summary>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a reset change.
            </summary>
            <param name="action">The action that caused the event (must be Reset).</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Object)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a one-item change.
            </summary>
            <param name="action">The action that caused the event; can only be Reset, Add or Remove action.</param>
            <param name="changedItem">The item affected by the change.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Object,System.Int32)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a one-item change.
            </summary>
            <param name="action">The action that caused the event.</param>
            <param name="changedItem">The item affected by the change.</param>
            <param name="index">The index where the change occurred.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a multi-item change.
            </summary>
            <param name="action">The action that caused the event.</param>
            <param name="changedItems">The items affected by the change.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList,System.Int32)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a multi-item change (or a reset).
            </summary>
            <param name="action">The action that caused the event.</param>
            <param name="changedItems">The items affected by the change.</param>
            <param name="startingIndex">The index where the change occurred.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Object,System.Object)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a one-item Replace event.
            </summary>
            <param name="action">Can only be a Replace action.</param>
            <param name="newItem">The new item replacing the original item.</param>
            <param name="oldItem">The original item that is replaced.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Object,System.Object,System.Int32)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a one-item Replace event.
            </summary>
            <param name="action">Can only be a Replace action.</param>
            <param name="newItem">The new item replacing the original item.</param>
            <param name="oldItem">The original item that is replaced.</param>
            <param name="index">The index of the item being replaced.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList,System.Collections.IList)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a multi-item Replace event.
            </summary>
            <param name="action">Can only be a Replace action.</param>
            <param name="newItems">The new items replacing the original items.</param>
            <param name="oldItems">The original items that are replaced.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList,System.Collections.IList,System.Int32)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a multi-item Replace event.
            </summary>
            <param name="action">Can only be a Replace action.</param>
            <param name="newItems">The new items replacing the original items.</param>
            <param name="oldItems">The original items that are replaced.</param>
            <param name="startingIndex">The starting index of the items being replaced.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Object,System.Int32,System.Int32)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a one-item Move event.
            </summary>
            <param name="action">Can only be a Move action.</param>
            <param name="changedItem">The item affected by the change.</param>
            <param name="index">The new index for the changed item.</param>
            <param name="oldIndex">The old index for the changed item.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList,System.Int32,System.Int32)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs that describes a multi-item Move event.
            </summary>
            <param name="action">The action that caused the event.</param>
            <param name="changedItems">The items affected by the change.</param>
            <param name="index">The new index for the changed items.</param>
            <param name="oldIndex">The old index for the changed items.</param>
        </member>
        <member name="M:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.#ctor(PlatformSupport.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList,System.Collections.IList,System.Int32,System.Int32)">
            <summary>
            Construct a NotifyCollectionChangedEventArgs with given fields (no validation). Used by WinRT marshaling.
            </summary>
        </member>
        <member name="P:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.Action">
            <summary>
            The action that caused the event.
            </summary>
        </member>
        <member name="P:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.NewItems">
            <summary>
            The items affected by the change.
            </summary>
        </member>
        <member name="P:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.OldItems">
            <summary>
            The old items affected by the change (for Replace events).
            </summary>
        </member>
        <member name="P:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.NewStartingIndex">
            <summary>
            The index where the change occurred.
            </summary>
        </member>
        <member name="P:PlatformSupport.Collections.Specialized.NotifyCollectionChangedEventArgs.OldStartingIndex">
            <summary>
            The old index where the change occurred (for Move events).
            </summary>
        </member>
    </members>
</doc>
